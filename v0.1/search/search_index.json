{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Frequenz CS Reporting Library","text":""},{"location":"#overview","title":"Overview","text":"<p>Streamlit library that ships a ready-to-use client reporting UI. It fetches data from the Frequenz reporting API, applies the energy reporting utilities from <code>frequenz-lib-notebooks</code>, and renders dashboards, tables, and plots with reusable Streamlit components.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pre-built Streamlit app with navigation, landing page, and reporting view.</li> <li>Connects to the Frequenz reporting API to fetch microgrid measurements.</li> <li>Ready-made dashboards (metrics, plots, and tables) powered by   <code>frequenz-lib-notebooks</code>.</li> <li>Reusable components (sidebar filters, charts, tables) for your own pages.</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<ol> <li>Install the library (Python 3.12):    <pre><code>pip install \"frequenz-cs-reporting\"\n</code></pre></li> <li>Provide environment variables (see below). A <code>.env</code> file works with Streamlit:    <pre><code>REPORTING_API_URL=https://your-reporting-endpoint\nAPI_KEY=your-api-key\nAPI_SECRET=your-api-secret\nMICROGRID_CONFIG_DIR=toml_directory/\n</code></pre></li> <li>Add .toml files to the toml_directory.</li> <li>Run the bundled UI from the repo root:    <pre><code>streamlit run app.py\n</code></pre>    Use the sidebar to pick a microgrid, date range, timezone, and resolution.</li> </ol>"},{"location":"#configuration","title":"Configuration","text":""},{"location":"#environment","title":"Environment","text":"<ul> <li><code>REPORTING_API_URL</code> (required): Base URL for the Frequenz reporting API.</li> <li><code>API_KEY</code> and <code>API_SECRET</code> (required): Credentials used by the data client.</li> <li><code>MICROGRID_CONFIG_DIR</code> (optional): Directory containing TOML microgrid   configs. Defaults to <code>toml_directory/</code>.</li> </ul>"},{"location":"#microgrid-configs","title":"Microgrid configs","text":"<p>Microgrid definitions are loaded from TOML files in <code>MICROGRID_CONFIG_DIR</code>.</p>"},{"location":"#running-the-streamlit-app","title":"Running the Streamlit app","text":"<p>The app entry point is <code>app.py</code>. When you run <code>streamlit run app.py</code>, it:</p> <ul> <li>Discovers pages from <code>frequenz.cs_reporting.app_pages</code> (the default   build ships <code>Home</code> and <code>Reporting</code> pages).</li> <li>Loads microgrid configs from <code>MICROGRID_CONFIG_DIR</code> and lists available IDs.</li> <li>Fetches data via the reporting API.</li> </ul>"},{"location":"#running-in-deepnote","title":"Running in Deepnote","text":"<ul> <li>Running in Deepnote is supported; required environment variables can be injected via the Deepnote integration.</li> <li>Add this library as a requirement in requirements.txt</li> <li>Add the docker image from dockerhub (currently named: CS-Reporting in deepnote).</li> <li>Copy the app.py to the folder structure in Deepnote.</li> <li>Click on create_streamlit_application in Deepnote UI to create the app.</li> </ul>"},{"location":"#library-usage","title":"Library usage","text":"<p>Fetch microgrid data programmatically (sync wrapper shown):</p> <pre><code>from datetime import datetime, timedelta\nfrom frequenz.cs_reporting.services.data_service import get_microgrid_data\n\ndf = get_microgrid_data(\n    microgrid_id=241,\n    start_date=datetime(2024, 1, 1),\n    end_date=datetime(2024, 1, 2),\n    resolution=timedelta(minutes=15),\n)\n</code></pre> <p>Build your own Streamlit page and add it to the navigation by defining a <code>PageSpec</code> in <code>frequenz.cs_reporting.app_pages</code>:</p> <pre><code># app_pages/custom.py\nfrom frequenz.cs_reporting.rep_cs_core.page_spec import PageSpec\nimport streamlit as st\n\ndef render() -&gt; None:\n    st.title(\"Custom view\")\n    st.write(\"Add your own charts or tables here.\")\n\nPAGE = PageSpec(key=\"custom\", title=\"Custom\", icon=\"\ud83d\udee0\ufe0f\", order=10, render=render)\n</code></pre>"},{"location":"#development","title":"Development","text":"<ul> <li>Install dev tools: <code>pip install -e \".[dev]\"</code>.</li> <li>Run tests: <code>nox -l</code> to see sessions, e.g. <code>nox -s tests</code>.</li> <li>Build docs with MkDocs (<code>README.md</code> is the landing page). After installing the   mkdocs extra you can use the <code>docs</code> nox session (if available) or run   <code>mkdocs serve</code>.</li> </ul>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.12</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz CS Reporting Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>cs_reporting<ul> <li>app_pages<ul> <li>dashboard</li> <li>home</li> <li>solar</li> </ul> </li> <li>assets</li> <li>components<ul> <li>inputs</li> <li>plot_charts</li> <li>sidebar_inputs</li> <li>tables</li> <li>ui</li> </ul> </li> <li>constants</li> <li>rep_cs_core<ul> <li>config</li> <li>page_spec</li> </ul> </li> <li>services<ul> <li>client_factory</li> <li>data_service</li> </ul> </li> <li>utils<ul> <li>env</li> <li>time</li> </ul> </li> <li>views<ul> <li>dashboard</li> <li>metric_renderers</li> <li>plot_renderers</li> <li>sections</li> <li>table_renderers</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/cs_reporting/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/#frequenz.cs_reporting","title":"frequenz.cs_reporting","text":"<p>Top-level package for Frequenz reporting utilities and views.</p>"},{"location":"reference/frequenz/cs_reporting/constants/","title":"constants","text":""},{"location":"reference/frequenz/cs_reporting/constants/#frequenz.cs_reporting.constants","title":"frequenz.cs_reporting.constants","text":"<p>Shared constants for the reporting library.</p>"},{"location":"reference/frequenz/cs_reporting/constants/#frequenz.cs_reporting.constants-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/constants/#frequenz.cs_reporting.constants.TablesResult","title":"frequenz.cs_reporting.constants.TablesResult","text":"<p>               Bases: <code>TypedDict</code></p> <p>Container for all tabular results produced by the energy system analysis.</p> <p>This TypedDict groups together summary tables, technology-specific analyses, and key performance metrics returned by the model.</p> Source code in <code>src/frequenz/cs_reporting/constants.py</code> <pre><code>class TablesResult(TypedDict):\n    \"\"\"Container for all tabular results produced by the energy system analysis.\n\n    This TypedDict groups together summary tables, technology-specific analyses,\n    and key performance metrics returned by the model.\n    \"\"\"\n\n    power_table: pd.DataFrame\n    metrics: dict[str, float | str | None]\n    pv_analysis: pd.DataFrame\n    batt_analysis: pd.DataFrame\n    chp_analysis: pd.DataFrame\n    wind_analysis: pd.DataFrame\n    ev_analysis: pd.DataFrame\n    overview_df: pd.DataFrame\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/app_pages/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/#frequenz.cs_reporting.app_pages","title":"frequenz.cs_reporting.app_pages","text":"<p>Frequenz CS Reporting App Pages.</p>"},{"location":"reference/frequenz/cs_reporting/app_pages/dashboard/","title":"dashboard","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/dashboard/#frequenz.cs_reporting.app_pages.dashboard","title":"frequenz.cs_reporting.app_pages.dashboard","text":"<p>Dashboard page to explore microgrid data and visualizations.</p>"},{"location":"reference/frequenz/cs_reporting/app_pages/dashboard/#frequenz.cs_reporting.app_pages.dashboard-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/dashboard/#frequenz.cs_reporting.app_pages.dashboard-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/dashboard/#frequenz.cs_reporting.app_pages.dashboard.render","title":"frequenz.cs_reporting.app_pages.dashboard.render","text":"<pre><code>render() -&gt; None\n</code></pre> <p>Render the Frequenz Monitoring Dashboard page.</p> <p>Collects sidebar inputs, fetches microgrid data, prepares it for analysis, and renders the dashboard views.</p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/app_pages/dashboard.py</code> <pre><code>def render() -&gt; None:\n    \"\"\"Render the Frequenz Monitoring Dashboard page.\n\n    Collects sidebar inputs, fetches microgrid data, prepares it for analysis,\n    and renders the dashboard views.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    # Page header\n    st.title(\"\ud83d\udcc8 Frequenz Monitoring Dashboard\")\n    st.caption(\"Explore data and plots.\")\n\n    # Collect user inputs from sidebar\n    today = date.today()\n    selections = collect_sidebar_inputs(\n        default_start=today,\n        default_end=today,\n        resolution_options=(\"15min\", \"30min\", \"1hour\"),\n        default_resolution=\"15min\",\n    )\n\n    timezone = selections[\"timezone\"]\n    # Extract and convert inputs\n    microgrid_id = selections[\"microgrid_id\"]\n    # set_date_to_midnight returns TZ-aware datetimes aligned with the user's timezone\n    start_date = set_date_to_midnight(selections[\"start_date\"], timezone)\n    end_date = set_date_to_midnight(selections[\"end_date\"], timezone)\n\n    # Validate date range\n    if start_date &gt; end_date:\n        st.warning(\n            \"End date must be on or after the start date. Please adjust your selection.\"\n        )\n        st.stop()\n\n    try:\n        resolution = _parse_resolution(selections[\"resolution\"])\n    except ValueError as exc:\n        st.error(str(exc))\n        st.stop()\n\n    # Fetch microgrid configuration\n    component_types = list(get_component_types(microgrid_id))\n    mcfg = get_microgrid_config(microgrid_id)\n\n    # We extend the fetch end date by 1 day to ensure the API returns data\n    # for the full duration of the selected end_date.\n    fetch_end_date = end_date + timedelta(days=1)\n\n    # Fetch data with error handling\n    try:\n        with st.spinner(\"Loading microgrid data...\"):\n            df = get_microgrid_data(\n                microgrid_id=microgrid_id,\n                start_date=start_date,\n                # Use the extended date here to ensure we get the full last day\n                end_date=fetch_end_date,\n                resolution=resolution,\n            )\n    except (RuntimeError, ValueError, OSError) as e:\n        st.error(f\"Failed to fetch data: {e}\")\n        st.stop()\n\n    # Check for empty results\n    if df.empty:\n        st.warning(\"No data for the selected filters.\")\n        st.stop()\n\n    # Normalize the dataframe (Handle Index)\n    df_prepared = _prepare_dataframe(df)\n\n    # Build and render dashboard\n    mapper = ColumnMapper.from_default()\n    master_df = build_master_df(df_prepared, component_types, mcfg, mapper)\n    render_dashboard(\n        master_df,\n        resolution=resolution,\n        component_types=component_types,\n        mapper=mapper,\n    )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/app_pages/home/","title":"home","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/home/#frequenz.cs_reporting.app_pages.home","title":"frequenz.cs_reporting.app_pages.home","text":"<p>Home page introducing the Frequenz reporting suite.</p>"},{"location":"reference/frequenz/cs_reporting/app_pages/home/#frequenz.cs_reporting.app_pages.home-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/home/#frequenz.cs_reporting.app_pages.home-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/home/#frequenz.cs_reporting.app_pages.home.render","title":"frequenz.cs_reporting.app_pages.home.render","text":"<pre><code>render() -&gt; None\n</code></pre> <p>Render the landing page with a welcome message and background.</p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/app_pages/home.py</code> <pre><code>def render() -&gt; None:\n    \"\"\"Render the landing page with a welcome message and background.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    _set_page_bg(BACKGROUND_PATH)\n\n    # Content on top of the background\n    st.markdown(\n        f\"\"\"\n        &lt;div style=\"{HERO_CARD_STYLE.strip()}\"&gt;\n            &lt;h1&gt;Welcome to the Frequenz Reporting Suite&lt;/h1&gt;\n            &lt;p&gt;&lt;em&gt;Operational intelligence at a glance.&lt;/em&gt;&lt;/p&gt;\n            &lt;p&gt;\n                The Frequenz Reporting Suite provides visibility and insights across your energy\n                infrastructure. Use the navigation sidebar to explore live dashboards, solar\n                performance, and asset optimization tools tailored for your organization.\n            &lt;/p&gt;\n        &lt;/div&gt;\n        \"\"\",\n        unsafe_allow_html=True,\n    )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/app_pages/solar/","title":"solar","text":""},{"location":"reference/frequenz/cs_reporting/app_pages/solar/#frequenz.cs_reporting.app_pages.solar","title":"frequenz.cs_reporting.app_pages.solar","text":"<p>Placeholder for the solar monitoring page.</p>"},{"location":"reference/frequenz/cs_reporting/assets/","title":"assets","text":""},{"location":"reference/frequenz/cs_reporting/assets/#frequenz.cs_reporting.assets","title":"frequenz.cs_reporting.assets","text":"<p>Convenience exports for asset-related modules.</p>"},{"location":"reference/frequenz/cs_reporting/components/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/components/#frequenz.cs_reporting.components","title":"frequenz.cs_reporting.components","text":"<p>UI component helpers for the Frequenz reporting app.</p>"},{"location":"reference/frequenz/cs_reporting/components/inputs/","title":"inputs","text":""},{"location":"reference/frequenz/cs_reporting/components/inputs/#frequenz.cs_reporting.components.inputs","title":"frequenz.cs_reporting.components.inputs","text":"<p>Input widgets used across reporting pages.</p>"},{"location":"reference/frequenz/cs_reporting/components/inputs/#frequenz.cs_reporting.components.inputs-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/components/inputs/#frequenz.cs_reporting.components.inputs.microgrid_selector","title":"frequenz.cs_reporting.components.inputs.microgrid_selector","text":"<pre><code>microgrid_selector(\n    label: str = \"Microgrid ID\",\n    ids: Iterable[int] = range(1, 2),\n    key_prefix: str = \"\",\n    container: Any | None = None,\n) -&gt; int\n</code></pre> <p>Render a selectbox for choosing a microgrid ID.</p> PARAMETER DESCRIPTION <code>label</code> <p>UI label for the selector.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Microgrid ID'</code> </p> <code>ids</code> <p>Iterable of available microgrid IDs.</p> <p> TYPE: <code>Iterable[int]</code> DEFAULT: <code>range(1, 2)</code> </p> <code>key_prefix</code> <p>Optional prefix for Streamlit widget keys.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>container</code> <p>Optional Streamlit container to render into.</p> <p> TYPE: <code>Any | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Selected microgrid identifier.</p> Source code in <code>src/frequenz/cs_reporting/components/inputs.py</code> <pre><code>def microgrid_selector(\n    label: str = \"Microgrid ID\",\n    ids: Iterable[int] = range(1, 2),\n    key_prefix: str = \"\",\n    container: Any | None = None,\n) -&gt; int:\n    \"\"\"Render a selectbox for choosing a microgrid ID.\n\n    Args:\n        label: UI label for the selector.\n        ids: Iterable of available microgrid IDs.\n        key_prefix: Optional prefix for Streamlit widget keys.\n        container: Optional Streamlit container to render into.\n\n    Returns:\n        Selected microgrid identifier.\n    \"\"\"\n    target = _resolve_container(container)\n    options: list[int] = list(ids)\n    value = target.selectbox(\n        label, options=options, index=0, key=f\"{key_prefix}microgrid_id\"\n    )\n\n    return cast(int, value)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/components/plot_charts/","title":"plot_charts","text":""},{"location":"reference/frequenz/cs_reporting/components/plot_charts/#frequenz.cs_reporting.components.plot_charts","title":"frequenz.cs_reporting.components.plot_charts","text":"<p>Chart rendering functions for the reporting module.</p>"},{"location":"reference/frequenz/cs_reporting/components/plot_charts/#frequenz.cs_reporting.components.plot_charts-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/components/plot_charts/#frequenz.cs_reporting.components.plot_charts.plot_percentage_bar","title":"frequenz.cs_reporting.components.plot_charts.plot_percentage_bar","text":"<pre><code>plot_percentage_bar(\n    data_points: dict[str, float | None], total_key: str\n) -&gt; Figure\n</code></pre> <p>Render a stacked percentage bar showing contributions to a total.</p> PARAMETER DESCRIPTION <code>data_points</code> <p>Mapping of labels to numeric values.</p> <p> TYPE: <code>dict[str, float | None]</code> </p> <code>total_key</code> <p>Key representing the total value in <code>data_points</code>.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>Plotly figure containing the stacked bar chart.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>total_key</code> is missing from <code>data_points</code>.</p> Source code in <code>src/frequenz/cs_reporting/components/plot_charts.py</code> <pre><code>def plot_percentage_bar(\n    data_points: dict[str, float | None], total_key: str\n) -&gt; go.Figure:\n    \"\"\"Render a stacked percentage bar showing contributions to a total.\n\n    Args:\n        data_points: Mapping of labels to numeric values.\n        total_key: Key representing the total value in ``data_points``.\n\n    Returns:\n        Plotly figure containing the stacked bar chart.\n\n    Raises:\n        ValueError: If ``total_key`` is missing from ``data_points``.\n    \"\"\"\n    if total_key not in data_points:\n        raise ValueError(f\"Total key '{total_key}' not found.\")\n\n    # sanitize values\n    clean = {k: (float(v) if v is not None else 0.0) for k, v in data_points.items()}\n    total = clean[total_key]\n    if total &lt;= 0:\n        fig = go.Figure()\n        fig.update_layout(\n            showlegend=False,\n            annotations=[\n                {\n                    \"text\": \"No data to display: total is zero or negative\",\n                    \"x\": 0.5,\n                    \"xref\": \"paper\",\n                    \"y\": 0.5,\n                    \"yref\": \"paper\",\n                    \"showarrow\": False,\n                    \"font\": {\"size\": 14, \"color\": \"gray\"},\n                }\n            ],\n        )\n        return fig\n\n    # segments\n    used = sum(v for k, v in clean.items() if k != total_key)\n    segments = {k: v for k, v in clean.items() if k != total_key and v &gt; 0}\n    display_base = max(total, used)\n    leftover = max(0.0, display_base - used)\n\n    # Only add \"Others\" if it has a positive value\n    if leftover &gt; 0:\n        segments[\"Others\"] = leftover\n\n    # compute percentages\n    seg_with_pct = [\n        (k, v, (v / display_base * 100.0 if display_base &gt; 0 else 0.0))\n        for k, v in segments.items()\n    ]\n\n    # sort left \u2192 right by descending absolute value (so largest chunk comes first in bar)\n    seg_with_pct.sort(key=lambda x: x[1], reverse=True)\n\n    # colors\n    palette = px.colors.qualitative.Plotly\n    color_map, i = {}, 0\n    for label, _, _ in seg_with_pct:\n        if label == \"Others\":\n            color_map[label] = \"#7f7f7f\"\n        else:\n            color_map[label] = palette[i % len(palette)]\n            i += 1\n\n    # figure\n    fig = go.Figure()\n\n    for label, value, pct in seg_with_pct:\n        text = f\"{pct:.1f}%\" if value &gt; 0 else None\n        fig.add_trace(\n            go.Bar(\n                x=[pct],\n                y=[\"\"],\n                name=label,\n                orientation=\"h\",\n                marker={\"color\": color_map[label]},\n                text=text,\n                textposition=\"inside\",\n                insidetextanchor=\"middle\",\n                hovertemplate=f\"{label}: %{{x:.1f}}%&lt;extra&gt;&lt;/extra&gt;\",\n            )\n        )\n\n    fig.update_layout(\n        barmode=\"stack\",\n        xaxis={\n            \"title\": None,\n            \"range\": [0, 100],\n            \"tickformat\": \".0f%%\",  # show % ticks\n            \"showgrid\": False,\n            \"zeroline\": False,\n        },\n        yaxis={\"showticklabels\": False},\n        height=160,  # controls bar thickness\n        margin={\"l\": 0, \"r\": 0, \"t\": 20, \"b\": 40},\n        legend={\n            \"orientation\": \"h\",\n            \"yanchor\": \"top\",\n            \"y\": -0.35,  # place legend below bar\n            \"xanchor\": \"center\",\n            \"x\": 0.5,\n        },\n    )\n\n    fig.update_layout(\n        annotations=[\n            {\n                \"text\": f\"{total_key}: {total:.0f} kWh\",\n                \"x\": 0.5,\n                \"xref\": \"paper\",\n                \"y\": 1.3,\n                \"yref\": \"paper\",\n                \"showarrow\": False,\n                \"font\": {\"size\": 14, \"color\": \"black\"},\n            }\n        ],\n        margin={\"t\": 40},  # add extra top margin for annotation\n    )\n    return fig\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/components/sidebar_inputs/","title":"sidebar_inputs","text":""},{"location":"reference/frequenz/cs_reporting/components/sidebar_inputs/#frequenz.cs_reporting.components.sidebar_inputs","title":"frequenz.cs_reporting.components.sidebar_inputs","text":"<p>Sidebar filter rendering helpers.</p>"},{"location":"reference/frequenz/cs_reporting/components/sidebar_inputs/#frequenz.cs_reporting.components.sidebar_inputs-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/components/sidebar_inputs/#frequenz.cs_reporting.components.sidebar_inputs.collect_sidebar_inputs","title":"frequenz.cs_reporting.components.sidebar_inputs.collect_sidebar_inputs","text":"<pre><code>collect_sidebar_inputs(\n    *,\n    default_start: date,\n    default_end: date,\n    resolution_options: Sequence[str] = (\n        \"15min\",\n        \"30min\",\n        \"1hour\",\n        \"4hour\",\n    ),\n    default_resolution: str = \"15min\",\n    timezone_options: Sequence[str] = TIMEZONE_OPTIONS,\n    default_timezone: str = \"Europe/Berlin\",\n    key_prefix: str = \"\"\n) -&gt; dict[str, Any]\n</code></pre> <p>Render structured sidebar filters with clear visual hierarchy.</p> <p>Creates an organized sidebar with sections for microgrid selection, date range, and resolution. Uses icons, dividers, and proper grouping for professional appearance and better UX.</p> PARAMETER DESCRIPTION <code>default_start</code> <p>Default start date for the date picker.</p> <p> TYPE: <code>date</code> </p> <code>default_end</code> <p>Default end date for the date picker.</p> <p> TYPE: <code>date</code> </p> <code>resolution_options</code> <p>Allowed resolution values for selection.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>('15min', '30min', '1hour', '4hour')</code> </p> <code>default_resolution</code> <p>Default resolution shown initially.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'15min'</code> </p> <code>timezone_options</code> <p>Allowed timezone values for selection.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>TIMEZONE_OPTIONS</code> </p> <code>default_timezone</code> <p>Default timezone shown initially.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Europe/Berlin'</code> </p> <code>key_prefix</code> <p>Optional prefix for Streamlit widget keys.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary containing <code>microgrid_id</code>, <code>start_date</code>, <code>end_date</code>, <code>timezone</code>, and <code>resolution</code> selected by the user.</p> Source code in <code>src/frequenz/cs_reporting/components/sidebar_inputs.py</code> <pre><code>def collect_sidebar_inputs(\n    *,\n    default_start: date,\n    default_end: date,\n    resolution_options: Sequence[str] = (\"15min\", \"30min\", \"1hour\", \"4hour\"),\n    default_resolution: str = \"15min\",\n    timezone_options: Sequence[str] = TIMEZONE_OPTIONS,\n    default_timezone: str = \"Europe/Berlin\",\n    key_prefix: str = \"\",\n) -&gt; dict[str, Any]:\n    \"\"\"Render structured sidebar filters with clear visual hierarchy.\n\n    Creates an organized sidebar with sections for microgrid selection, date\n    range, and resolution. Uses icons, dividers, and proper grouping for\n    professional appearance and better UX.\n\n    Args:\n        default_start: Default start date for the date picker.\n        default_end: Default end date for the date picker.\n        resolution_options: Allowed resolution values for selection.\n        default_resolution: Default resolution shown initially.\n        timezone_options: Allowed timezone values for selection.\n        default_timezone: Default timezone shown initially.\n        key_prefix: Optional prefix for Streamlit widget keys.\n\n    Returns:\n        Dictionary containing ``microgrid_id``, ``start_date``,\n            ``end_date``, ``timezone``, and ``resolution`` selected by the user.\n    \"\"\"\n    # Header with icon and caption\n    st.sidebar.header(\"\ud83c\udf9b\ufe0f Filter Einstellungen\")\n    st.sidebar.caption(\"W\u00e4hlen Sie die gew\u00fcnschten Parameter f\u00fcr die Analyse\")\n\n    form_key = f\"{key_prefix}filters_form\" if key_prefix else \"filters_form\"\n    state_key = f\"{key_prefix}applied_filters\" if key_prefix else \"applied_filters\"\n\n    with st.sidebar.form(form_key):\n        # Microgrid Section\n        st.subheader(\"\ud83c\udfed Microgrid\")\n        microgrid_id = inputs.microgrid_selector(\n            label=\"Microgrid ID\",\n            ids=get_microgrid_ids(),\n            key_prefix=key_prefix,\n            container=st,\n        )\n\n        st.divider()\n\n        # Date &amp; Time Section\n        st.subheader(\"\ud83d\udcc5 Zeitraum\")\n\n        today = date.today()\n        fallback_start = default_start or (today - timedelta(days=7))\n\n        start_key = f\"{key_prefix}start_date\"\n        end_key = f\"{key_prefix}end_date\"\n        timezone_key = f\"{key_prefix}timezone\"\n\n        start_initial = st.session_state.get(start_key, fallback_start)\n\n        columns = st.columns(2)\n        with columns[0]:\n            start_date = st.date_input(\n                \"Start\",\n                value=start_initial,\n                max_value=today,\n                key=start_key,\n            )\n\n        end_initial = min(\n            st.session_state.get(end_key, default_end or today),\n            today,\n        )\n\n        with columns[1]:\n            end_date = st.date_input(\n                \"Ende\",\n                value=end_initial,\n                max_value=today,\n                key=end_key,\n            )\n\n        timezone_options_list = list(timezone_options)\n        timezone_index = next(\n            (\n                idx\n                for idx, option in enumerate(timezone_options_list)\n                if option == default_timezone\n            ),\n            0,\n        )\n\n        timezone = st.selectbox(\n            \"\ud83c\udf0d Zeitzone\",\n            options=timezone_options_list,\n            index=timezone_index,\n            key=timezone_key,\n            help=\"Zeitzone zur Interpretation der ausgew\u00e4hlten Tage\",\n        )\n\n        st.divider()\n\n        # Resolution selector (full width)\n        resolution = st.selectbox(\n            \"\u23f1\ufe0f Aufl\u00f6sung\",\n            options=list(resolution_options),\n            index=next(\n                (\n                    idx\n                    for idx, option in enumerate(resolution_options)\n                    if option == default_resolution\n                ),\n                0,\n            ),\n            key=f\"{key_prefix}resolution\",\n            help=\"Zeitliche Aufl\u00f6sung der Daten\",\n        )\n\n        st.divider()\n\n        # Prominent submit button\n        submitted = st.form_submit_button(\n            \"\u2713 Filter anwenden\", use_container_width=True, type=\"primary\"\n        )\n\n    current_selection = {\n        \"microgrid_id\": microgrid_id,\n        \"start_date\": start_date,\n        \"end_date\": end_date,\n        \"timezone\": timezone,\n        \"resolution\": resolution,\n    }\n\n    if submitted or state_key not in st.session_state:\n        st.session_state[state_key] = current_selection\n\n    return dict(st.session_state[state_key])\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/components/tables/","title":"tables","text":""},{"location":"reference/frequenz/cs_reporting/components/tables/#frequenz.cs_reporting.components.tables","title":"frequenz.cs_reporting.components.tables","text":"<p>AgGrid helpers for rendering reporting tables.</p>"},{"location":"reference/frequenz/cs_reporting/components/tables/#frequenz.cs_reporting.components.tables-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/components/tables/#frequenz.cs_reporting.components.tables.aggrid_table","title":"frequenz.cs_reporting.components.tables.aggrid_table","text":"<pre><code>aggrid_table(\n    df: DataFrame,\n    *,\n    key_prefix: str,\n    page_size: int = 12,\n    header_color: str = \"#1565c0\",\n    height: int = 420,\n    theme: str = \"alpine\",\n    default_col_width: int = 180,\n    min_col_width: int = 160\n) -&gt; None\n</code></pre> <p>Render a dataframe using AgGrid with sensible defaults.</p> PARAMETER DESCRIPTION <code>df</code> <p>Dataframe to display; an empty dataframe is used when invalid.</p> <p> TYPE: <code>DataFrame</code> </p> <code>key_prefix</code> <p>Unique prefix for Streamlit state keys.</p> <p> TYPE: <code>str</code> </p> <code>page_size</code> <p>Preferred page size for pagination controls.</p> <p> TYPE: <code>int</code> DEFAULT: <code>12</code> </p> <code>header_color</code> <p>Header background color.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'#1565c0'</code> </p> <code>height</code> <p>Height of the grid container in pixels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>420</code> </p> <code>theme</code> <p>AgGrid theme name.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'alpine'</code> </p> <code>default_col_width</code> <p>Default column width in pixels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>180</code> </p> <code>min_col_width</code> <p>Minimum column width in pixels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>160</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/components/tables.py</code> <pre><code>def aggrid_table(\n    df: pd.DataFrame,\n    *,\n    key_prefix: str,\n    page_size: int = 12,\n    header_color: str = \"#1565c0\",\n    height: int = 420,\n    theme: str = \"alpine\",  # 'alpine' | 'balham' | 'material' | etc.\n    default_col_width: int = 180,\n    min_col_width: int = 160,\n) -&gt; None:\n    \"\"\"Render a dataframe using AgGrid with sensible defaults.\n\n    Args:\n        df: Dataframe to display; an empty dataframe is used when invalid.\n        key_prefix: Unique prefix for Streamlit state keys.\n        page_size: Preferred page size for pagination controls.\n        header_color: Header background color.\n        height: Height of the grid container in pixels.\n        theme: AgGrid theme name.\n        default_col_width: Default column width in pixels.\n        min_col_width: Minimum column width in pixels.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if df is None or not isinstance(df, pd.DataFrame):\n        df = pd.DataFrame()\n\n    # Initialize session state for page size if it doesn't exist\n    if f\"{key_prefix}_page_size\" not in st.session_state:\n        st.session_state[f\"{key_prefix}_page_size\"] = page_size\n\n    # --- Build grid options from dataframe ---\n    gb = GridOptionsBuilder.from_dataframe(df)\n    gb.configure_pagination(\n        enabled=True,\n        paginationAutoPageSize=True,\n        # paginationPageSize=st.session_state[f'{key_prefix}_page_size'],\n    )\n\n    gb.configure_default_column(\n        resizable=True,\n        sortable=True,\n        filter=True,\n        wrapText=False,\n        autoHeight=False,\n        width=default_col_width,\n        minWidth=min_col_width,\n        cellStyle={\"textAlign\": \"left\"},  # left-align body cells\n        suppressSizeToFit=True,\n        suppressAutoSize=True,\n    )\n\n    # Fit columns on first load\n    grid_options = gb.build()\n\n    # --- Scoped CSS: blue header + centered labels ---\n    container_id = f\"agc_{key_prefix}\"\n    st.markdown(\n        f\"\"\"\n        &lt;style&gt;\n        /* scope to this grid instance only */\n        #{container_id} .ag-theme-{theme} .ag-header {{\n            background: {header_color} !important;\n            color: #fff !important;\n        }}\n        #{container_id} .ag-theme-{theme} .ag-header-cell-label {{\n            justify-content: center;     /* center header text */\n        }}\n        #{container_id} .ag-theme-{theme} .ag-cell {{\n            text-align: left !important; /* left align body */\n        }}\n        &lt;/style&gt;\n        \"\"\",\n        unsafe_allow_html=True,\n    )\n\n    # --- Render grid ---\n    with st.container():\n        st.markdown(f'&lt;div id=\"{container_id}\"&gt;', unsafe_allow_html=True)\n        _ = AgGrid(\n            df,\n            gridOptions=grid_options,\n            height=height,\n            theme=theme,\n            update_mode=GridUpdateMode.NO_UPDATE,\n            fit_columns_on_grid_load=False,\n            columns_auto_size_mode=ColumnsAutoSizeMode.NO_AUTOSIZE,\n            key=key_prefix,\n        )\n        st.markdown(\"&lt;/div&gt;\", unsafe_allow_html=True)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/components/ui/","title":"ui","text":""},{"location":"reference/frequenz/cs_reporting/components/ui/#frequenz.cs_reporting.components.ui","title":"frequenz.cs_reporting.components.ui","text":"<p>UI helpers for rendering plots and styled cards.</p>"},{"location":"reference/frequenz/cs_reporting/components/ui/#frequenz.cs_reporting.components.ui-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/components/ui/#frequenz.cs_reporting.components.ui.render_plot_card","title":"frequenz.cs_reporting.components.ui.render_plot_card","text":"<pre><code>render_plot_card(title: str, fig: object) -&gt; None\n</code></pre> <p>Render a plot inside a styled card.</p> PARAMETER DESCRIPTION <code>title</code> <p>Title displayed above the plot.</p> <p> TYPE: <code>str</code> </p> <code>fig</code> <p>Plotly or Matplotlib figure to render.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/components/ui.py</code> <pre><code>def render_plot_card(title: str, fig: object) -&gt; None:\n    \"\"\"Render a plot inside a styled card.\n\n    Args:\n        title: Title displayed above the plot.\n        fig: Plotly or Matplotlib figure to render.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    _ensure_plot_card_css()\n\n    # Use st.container() for proper styling\n    with st.container(border=True):\n        st.markdown(\n            f'&lt;div class=\"plot-card__title\"&gt;{title}&lt;/div&gt;', unsafe_allow_html=True\n        )\n\n        # Check the figure type to use the correct Streamlit component\n        if isinstance(fig, go.Figure):\n            st.plotly_chart(fig, width=\"stretch\")\n        elif isinstance(fig, Figure):\n            st.pyplot(fig)\n        else:\n            st.warning(\"Unsupported figure type.\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/rep_cs_core/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/rep_cs_core/#frequenz.cs_reporting.rep_cs_core","title":"frequenz.cs_reporting.rep_cs_core","text":"<p>Core configuration and contracts shared across reporting pages.</p>"},{"location":"reference/frequenz/cs_reporting/rep_cs_core/config/","title":"config","text":""},{"location":"reference/frequenz/cs_reporting/rep_cs_core/config/#frequenz.cs_reporting.rep_cs_core.config","title":"frequenz.cs_reporting.rep_cs_core.config","text":"<p>Configuration helpers for the reporting core package.</p>"},{"location":"reference/frequenz/cs_reporting/rep_cs_core/config/#frequenz.cs_reporting.rep_cs_core.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/rep_cs_core/config/#frequenz.cs_reporting.rep_cs_core.config.AppConfig","title":"frequenz.cs_reporting.rep_cs_core.config.AppConfig  <code>dataclass</code>","text":"<p>Container for library configuration.</p> ATTRIBUTE DESCRIPTION <code>paths</code> <p>Paths configuration values.</p> <p> TYPE: <code>Paths</code> </p> Source code in <code>src/frequenz/cs_reporting/rep_cs_core/config.py</code> <pre><code>@dataclass(frozen=True)\nclass AppConfig:\n    \"\"\"Container for library configuration.\n\n    Attributes:\n        paths: Paths configuration values.\n    \"\"\"\n\n    paths: Paths\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/rep_cs_core/config/#frequenz.cs_reporting.rep_cs_core.config.Paths","title":"frequenz.cs_reporting.rep_cs_core.config.Paths  <code>dataclass</code>","text":"<p>Filesystem paths used by the reporting app configuration.</p> ATTRIBUTE DESCRIPTION <code>microgrids_dir</code> <p>Root directory containing microgrid configuration files.</p> <p> TYPE: <code>Path</code> </p> Source code in <code>src/frequenz/cs_reporting/rep_cs_core/config.py</code> <pre><code>@dataclass(frozen=True)\nclass Paths:\n    \"\"\"Filesystem paths used by the reporting app configuration.\n\n    Attributes:\n        microgrids_dir: Root directory containing microgrid configuration files.\n    \"\"\"\n\n    microgrids_dir: Path\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/rep_cs_core/page_spec/","title":"page_spec","text":""},{"location":"reference/frequenz/cs_reporting/rep_cs_core/page_spec/#frequenz.cs_reporting.rep_cs_core.page_spec","title":"frequenz.cs_reporting.rep_cs_core.page_spec","text":"<p>Page specification dataclass used by Streamlit navigation.</p>"},{"location":"reference/frequenz/cs_reporting/rep_cs_core/page_spec/#frequenz.cs_reporting.rep_cs_core.page_spec-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/rep_cs_core/page_spec/#frequenz.cs_reporting.rep_cs_core.page_spec.PageSpec","title":"frequenz.cs_reporting.rep_cs_core.page_spec.PageSpec  <code>dataclass</code>","text":"<p>Page metadata used to build the navigation and render pages.</p> ATTRIBUTE DESCRIPTION <code>key</code> <p>Unique identifier for the page, used in navigation state.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>Human-readable title shown in the sidebar.</p> <p> TYPE: <code>str</code> </p> <code>icon</code> <p>Emoji or icon string used in the sidebar.</p> <p> TYPE: <code>str</code> </p> <code>order</code> <p>Sorting order for the navigation list.</p> <p> TYPE: <code>int</code> </p> <code>render</code> <p>Callable that renders the Streamlit page content.</p> <p> TYPE: <code>Callable[[], None]</code> </p> Source code in <code>src/frequenz/cs_reporting/rep_cs_core/page_spec.py</code> <pre><code>@dataclass(frozen=True)\nclass PageSpec:\n    \"\"\"Page metadata used to build the navigation and render pages.\n\n    Attributes:\n        key: Unique identifier for the page, used in navigation state.\n        title: Human-readable title shown in the sidebar.\n        icon: Emoji or icon string used in the sidebar.\n        order: Sorting order for the navigation list.\n        render: Callable that renders the Streamlit page content.\n    \"\"\"\n\n    key: str\n    title: str\n    icon: str\n    order: int\n    render: Callable[[], None]\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/services/#frequenz.cs_reporting.services","title":"frequenz.cs_reporting.services","text":"<p>Convenience exports for data service factories.</p>"},{"location":"reference/frequenz/cs_reporting/services/#frequenz.cs_reporting.services-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/services/#frequenz.cs_reporting.services.get_microgrid_client","title":"frequenz.cs_reporting.services.get_microgrid_client","text":"<pre><code>get_microgrid_client(microgrid_id: int) -&gt; MicrogridData\n</code></pre> <p>Create a MicrogridData client using cached configs.</p> <p>The client is not cached to avoid binding an async HTTP client to the wrong event loop when Streamlit reruns the app. Config files remain cached via <code>_load_microgrid_configs()</code>.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>Identifier for the target microgrid.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>MicrogridData</code> <p>Client ready to fetch microgrid data.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the specified microgrid ID is not found in configs.</p> Source code in <code>src/frequenz/cs_reporting/services/client_factory.py</code> <pre><code>def get_microgrid_client(microgrid_id: int) -&gt; component_data.MicrogridData:\n    \"\"\"Create a MicrogridData client using cached configs.\n\n    The client is not cached to avoid binding an async HTTP client to the wrong\n    event loop when Streamlit reruns the app. Config files remain cached via\n    `_load_microgrid_configs()`.\n\n    Args:\n        microgrid_id: Identifier for the target microgrid.\n\n    Returns:\n        Client ready to fetch microgrid data.\n\n    Raises:\n        KeyError: If the specified microgrid ID is not found in configs.\n    \"\"\"\n    server_url = require_env(\"REPORTING_API_URL\")\n    auth_key = require_env(\"API_KEY\")\n    sign_secret = require_env(\"API_SECRET\")\n\n    configs = _load_microgrid_configs()\n    if str(microgrid_id) not in configs:\n        raise KeyError(f\"Microgrid {microgrid_id} not found in configured microgrids.\")\n    return component_data.MicrogridData(\n        server_url=server_url,\n        auth_key=auth_key,\n        sign_secret=sign_secret,\n        microgrid_configs=configs,\n    )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/client_factory/","title":"client_factory","text":""},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory","title":"frequenz.cs_reporting.services.client_factory","text":"<p>Factories for microgrid client creation and configuration loading.</p>"},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory.get_component_types","title":"frequenz.cs_reporting.services.client_factory.get_component_types","text":"<pre><code>get_component_types(microgrid_id: int) -&gt; tuple[str, ...]\n</code></pre> <p>Return all component types configured for the microgrid.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>Identifier for the target microgrid.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>tuple[str, ...]</code> <p>Component type identifiers.</p> Source code in <code>src/frequenz/cs_reporting/services/client_factory.py</code> <pre><code>def get_component_types(microgrid_id: int) -&gt; tuple[str, ...]:\n    \"\"\"Return all component types configured for the microgrid.\n\n    Args:\n        microgrid_id: Identifier for the target microgrid.\n\n    Returns:\n        Component type identifiers.\n    \"\"\"\n    mcfg = _load_microgrid_configs()[str(microgrid_id)]\n    return tuple(mcfg.component_types())\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory.get_microgrid_client","title":"frequenz.cs_reporting.services.client_factory.get_microgrid_client","text":"<pre><code>get_microgrid_client(microgrid_id: int) -&gt; MicrogridData\n</code></pre> <p>Create a MicrogridData client using cached configs.</p> <p>The client is not cached to avoid binding an async HTTP client to the wrong event loop when Streamlit reruns the app. Config files remain cached via <code>_load_microgrid_configs()</code>.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>Identifier for the target microgrid.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>MicrogridData</code> <p>Client ready to fetch microgrid data.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the specified microgrid ID is not found in configs.</p> Source code in <code>src/frequenz/cs_reporting/services/client_factory.py</code> <pre><code>def get_microgrid_client(microgrid_id: int) -&gt; component_data.MicrogridData:\n    \"\"\"Create a MicrogridData client using cached configs.\n\n    The client is not cached to avoid binding an async HTTP client to the wrong\n    event loop when Streamlit reruns the app. Config files remain cached via\n    `_load_microgrid_configs()`.\n\n    Args:\n        microgrid_id: Identifier for the target microgrid.\n\n    Returns:\n        Client ready to fetch microgrid data.\n\n    Raises:\n        KeyError: If the specified microgrid ID is not found in configs.\n    \"\"\"\n    server_url = require_env(\"REPORTING_API_URL\")\n    auth_key = require_env(\"API_KEY\")\n    sign_secret = require_env(\"API_SECRET\")\n\n    configs = _load_microgrid_configs()\n    if str(microgrid_id) not in configs:\n        raise KeyError(f\"Microgrid {microgrid_id} not found in configured microgrids.\")\n    return component_data.MicrogridData(\n        server_url=server_url,\n        auth_key=auth_key,\n        sign_secret=sign_secret,\n        microgrid_configs=configs,\n    )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory.get_microgrid_config","title":"frequenz.cs_reporting.services.client_factory.get_microgrid_config","text":"<pre><code>get_microgrid_config(microgrid_id: int) -&gt; MicrogridConfig\n</code></pre> <p>Return the MicrogridConfig for a given microgrid.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>Identifier for the target microgrid.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>MicrogridConfig</code> <p>Loaded configuration for the microgrid.</p> Source code in <code>src/frequenz/cs_reporting/services/client_factory.py</code> <pre><code>def get_microgrid_config(microgrid_id: int) -&gt; MicrogridConfig:\n    \"\"\"Return the MicrogridConfig for a given microgrid.\n\n    Args:\n        microgrid_id: Identifier for the target microgrid.\n\n    Returns:\n        Loaded configuration for the microgrid.\n    \"\"\"\n    return _load_microgrid_configs()[str(microgrid_id)]\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/client_factory/#frequenz.cs_reporting.services.client_factory.get_microgrid_ids","title":"frequenz.cs_reporting.services.client_factory.get_microgrid_ids","text":"<pre><code>get_microgrid_ids() -&gt; list[int]\n</code></pre> <p>Return available microgrid IDs sorted ascending.</p> RETURNS DESCRIPTION <code>list[int]</code> <p>List of configured microgrid IDs.</p> Source code in <code>src/frequenz/cs_reporting/services/client_factory.py</code> <pre><code>@st.cache_data(show_spinner=False)\ndef get_microgrid_ids() -&gt; list[int]:\n    \"\"\"Return available microgrid IDs sorted ascending.\n\n    Returns:\n        List of configured microgrid IDs.\n    \"\"\"\n    return sorted(int(mid.replace(\"iot\", \"\")) for mid in _load_microgrid_configs())\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/data_service/","title":"data_service","text":""},{"location":"reference/frequenz/cs_reporting/services/data_service/#frequenz.cs_reporting.services.data_service","title":"frequenz.cs_reporting.services.data_service","text":"<p>Async and cached data access helpers for microgrid measurements.</p>"},{"location":"reference/frequenz/cs_reporting/services/data_service/#frequenz.cs_reporting.services.data_service-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/services/data_service/#frequenz.cs_reporting.services.data_service.fetch_microgrid_data","title":"frequenz.cs_reporting.services.data_service.fetch_microgrid_data  <code>async</code>","text":"<pre><code>fetch_microgrid_data(\n    microgrid_id: int,\n    start_date: datetime,\n    end_date: datetime,\n    resolution: timedelta,\n    timeout: float = 30.0,\n) -&gt; DataFrame\n</code></pre> <p>Fetch AC active power for a microgrid in <code>[start_date, end_date)</code>.</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>Identifier for the target microgrid.</p> <p> TYPE: <code>int</code> </p> <code>start_date</code> <p>Inclusive start date of the query range.</p> <p> TYPE: <code>datetime</code> </p> <code>end_date</code> <p>Exclusive end date of the query range.</p> <p> TYPE: <code>datetime</code> </p> <code>resolution</code> <p>Resampling period for the returned data.</p> <p> TYPE: <code>timedelta</code> </p> <code>timeout</code> <p>Request timeout in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe of AC active power measurements. Empty when no data is available.</p> Source code in <code>src/frequenz/cs_reporting/services/data_service.py</code> <pre><code>async def fetch_microgrid_data(\n    microgrid_id: int,\n    start_date: datetime,\n    end_date: datetime,\n    resolution: timedelta,\n    timeout: float = 30.0,\n) -&gt; pd.DataFrame:\n    \"\"\"Fetch AC active power for a microgrid in ``[start_date, end_date)``.\n\n    Args:\n        microgrid_id: Identifier for the target microgrid.\n        start_date: Inclusive start date of the query range.\n        end_date: Exclusive end date of the query range.\n        resolution: Resampling period for the returned data.\n        timeout: Request timeout in seconds.\n\n    Returns:\n        Dataframe of AC active power measurements. Empty when no\n            data is available.\n    \"\"\"\n    start_iso, end_iso = validate_range(start_date, end_date)\n    client = get_microgrid_client(microgrid_id)\n    component_types: tuple[str, ...] = get_component_types(microgrid_id)\n\n    coro = client.ac_active_power(\n        microgrid_id=microgrid_id,\n        component_types=component_types,\n        start=start_iso,\n        end=end_iso,\n        resampling_period=resolution,\n        keep_components=True,\n        splits=True,\n    )\n    df = await asyncio.wait_for(coro, timeout)\n\n    if df is None or (hasattr(df, \"empty\") and df.empty):\n        return pd.DataFrame()\n    return df\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/services/data_service/#frequenz.cs_reporting.services.data_service.get_microgrid_data","title":"frequenz.cs_reporting.services.data_service.get_microgrid_data","text":"<pre><code>get_microgrid_data(\n    microgrid_id: int,\n    start_date: datetime,\n    end_date: datetime,\n    resolution: timedelta,\n    timeout: float = 30.0,\n) -&gt; DataFrame\n</code></pre> <p>Sync wrapper for Streamlit pages with caching (5 min TTL).</p> PARAMETER DESCRIPTION <code>microgrid_id</code> <p>Identifier for the target microgrid.</p> <p> TYPE: <code>int</code> </p> <code>start_date</code> <p>Inclusive start date of the query range.</p> <p> TYPE: <code>datetime</code> </p> <code>end_date</code> <p>Exclusive end date of the query range.</p> <p> TYPE: <code>datetime</code> </p> <code>resolution</code> <p>Resampling period for the returned data.</p> <p> TYPE: <code>timedelta</code> </p> <code>timeout</code> <p>Request timeout in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe of AC active power measurements. Empty when no data is available.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If invoked from within an active event loop instead of using the async <code>fetch_microgrid_data</code>.</p> Source code in <code>src/frequenz/cs_reporting/services/data_service.py</code> <pre><code>@st.cache_data(ttl=300, show_spinner=False)\ndef get_microgrid_data(\n    microgrid_id: int,\n    start_date: datetime,\n    end_date: datetime,\n    resolution: timedelta,\n    timeout: float = 30.0,\n) -&gt; pd.DataFrame:\n    \"\"\"Sync wrapper for Streamlit pages with caching (5 min TTL).\n\n    Args:\n        microgrid_id: Identifier for the target microgrid.\n        start_date: Inclusive start date of the query range.\n        end_date: Exclusive end date of the query range.\n        resolution: Resampling period for the returned data.\n        timeout: Request timeout in seconds.\n\n    Returns:\n        Dataframe of AC active power measurements. Empty when no\n            data is available.\n\n    Raises:\n        RuntimeError: If invoked from within an active event loop instead of\n            using the async ``fetch_microgrid_data``.\n    \"\"\"\n    try:\n        asyncio.get_running_loop()\n    except RuntimeError:\n        # No active loop: safe to block\n        return asyncio.run(\n            fetch_microgrid_data(\n                microgrid_id, start_date, end_date, resolution, timeout=timeout\n            )\n        )\n    # Active loop: force caller to use the async API\n    raise RuntimeError(\n        \"get_microgrid_data() called from within an active event loop. \"\n        \"Use `await fetch_microgrid_data(...)` in async contexts.\"\n    )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/utils/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/utils/#frequenz.cs_reporting.utils","title":"frequenz.cs_reporting.utils","text":"<p>Utility helpers for the Frequenz reporting package.</p>"},{"location":"reference/frequenz/cs_reporting/utils/#frequenz.cs_reporting.utils-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/utils/#frequenz.cs_reporting.utils.require_env","title":"frequenz.cs_reporting.utils.require_env","text":"<pre><code>require_env(var: str) -&gt; str\n</code></pre> <p>Return an environment variable value or raise a clear error.</p> PARAMETER DESCRIPTION <code>var</code> <p>Name of the environment variable to read.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Environment variable value.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the environment variable is missing or empty.</p> Source code in <code>src/frequenz/cs_reporting/utils/env.py</code> <pre><code>def require_env(var: str) -&gt; str:\n    \"\"\"Return an environment variable value or raise a clear error.\n\n    Args:\n        var: Name of the environment variable to read.\n\n    Returns:\n        Environment variable value.\n\n    Raises:\n        RuntimeError: If the environment variable is missing or empty.\n    \"\"\"\n    val = os.getenv(var)\n    if not val:\n        raise RuntimeError(\n            f\"Missing or empty required environment variable `{var}`. \"\n            \"Set it in your environment or .env file.\"\n        )\n    return val\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/utils/#frequenz.cs_reporting.utils.to_iso8601","title":"frequenz.cs_reporting.utils.to_iso8601","text":"<pre><code>to_iso8601(d: DateLike) -&gt; str\n</code></pre> <p>Normalize any date-like input to an ISO8601 string.</p> PARAMETER DESCRIPTION <code>d</code> <p>Date-like input such as <code>str</code>, <code>datetime.date</code>, or <code>datetime.datetime</code> (including pandas equivalents).</p> <p> TYPE: <code>DateLike</code> </p> RETURNS DESCRIPTION <code>str</code> <p>ISO8601 formatted string.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the input is not recognized as date-like.</p> Source code in <code>src/frequenz/cs_reporting/utils/time.py</code> <pre><code>def to_iso8601(d: DateLike) -&gt; str:\n    \"\"\"Normalize any date-like input to an ISO8601 string.\n\n    Args:\n        d: Date-like input such as ``str``, ``datetime.date``, or\n            ``datetime.datetime`` (including pandas equivalents).\n\n    Returns:\n        ISO8601 formatted string.\n\n    Raises:\n        TypeError: If the input is not recognized as date-like.\n    \"\"\"\n    if hasattr(d, \"to_pydatetime\"):\n        d = d.to_pydatetime()\n\n    if isinstance(d, str):\n        return d\n    if isinstance(d, datetime):\n        return d.isoformat()\n    if isinstance(d, date):\n        return datetime(d.year, d.month, d.day).isoformat()\n    raise TypeError(f\"Invalid date-like value: {d!r}\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/utils/#frequenz.cs_reporting.utils.validate_range","title":"frequenz.cs_reporting.utils.validate_range","text":"<pre><code>validate_range(\n    start: DateLike, end: DateLike\n) -&gt; tuple[datetime, datetime]\n</code></pre> <p>Validate that the start value precedes the end value.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start date or datetime value.</p> <p> TYPE: <code>DateLike</code> </p> <code>end</code> <p>End date or datetime value.</p> <p> TYPE: <code>DateLike</code> </p> RETURNS DESCRIPTION <code>tuple[datetime, datetime]</code> <p>Original <code>start</code> and <code>end</code> values when valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>start</code> is greater than or equal to <code>end</code>.</p> Source code in <code>src/frequenz/cs_reporting/utils/time.py</code> <pre><code>def validate_range(start: DateLike, end: DateLike) -&gt; tuple[datetime, datetime]:\n    \"\"\"Validate that the start value precedes the end value.\n\n    Args:\n        start: Start date or datetime value.\n        end: End date or datetime value.\n\n    Returns:\n        Original ``start`` and ``end`` values when valid.\n\n    Raises:\n        ValueError: If ``start`` is greater than or equal to ``end``.\n    \"\"\"\n    start_dt = to_datetime(start)\n    end_dt = to_datetime(end)\n    if end_dt &lt;= start_dt:\n        raise ValueError(\"end_date must be after start_date\")\n    return start_dt, end_dt\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/utils/env/","title":"env","text":""},{"location":"reference/frequenz/cs_reporting/utils/env/#frequenz.cs_reporting.utils.env","title":"frequenz.cs_reporting.utils.env","text":"<p>Environment variable helpers.</p>"},{"location":"reference/frequenz/cs_reporting/utils/env/#frequenz.cs_reporting.utils.env-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/utils/env/#frequenz.cs_reporting.utils.env.require_env","title":"frequenz.cs_reporting.utils.env.require_env","text":"<pre><code>require_env(var: str) -&gt; str\n</code></pre> <p>Return an environment variable value or raise a clear error.</p> PARAMETER DESCRIPTION <code>var</code> <p>Name of the environment variable to read.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Environment variable value.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the environment variable is missing or empty.</p> Source code in <code>src/frequenz/cs_reporting/utils/env.py</code> <pre><code>def require_env(var: str) -&gt; str:\n    \"\"\"Return an environment variable value or raise a clear error.\n\n    Args:\n        var: Name of the environment variable to read.\n\n    Returns:\n        Environment variable value.\n\n    Raises:\n        RuntimeError: If the environment variable is missing or empty.\n    \"\"\"\n    val = os.getenv(var)\n    if not val:\n        raise RuntimeError(\n            f\"Missing or empty required environment variable `{var}`. \"\n            \"Set it in your environment or .env file.\"\n        )\n    return val\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/utils/time/","title":"time","text":""},{"location":"reference/frequenz/cs_reporting/utils/time/#frequenz.cs_reporting.utils.time","title":"frequenz.cs_reporting.utils.time","text":"<p>Time utilities for the reporting package.</p>"},{"location":"reference/frequenz/cs_reporting/utils/time/#frequenz.cs_reporting.utils.time-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/utils/time/#frequenz.cs_reporting.utils.time.to_iso8601","title":"frequenz.cs_reporting.utils.time.to_iso8601","text":"<pre><code>to_iso8601(d: DateLike) -&gt; str\n</code></pre> <p>Normalize any date-like input to an ISO8601 string.</p> PARAMETER DESCRIPTION <code>d</code> <p>Date-like input such as <code>str</code>, <code>datetime.date</code>, or <code>datetime.datetime</code> (including pandas equivalents).</p> <p> TYPE: <code>DateLike</code> </p> RETURNS DESCRIPTION <code>str</code> <p>ISO8601 formatted string.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the input is not recognized as date-like.</p> Source code in <code>src/frequenz/cs_reporting/utils/time.py</code> <pre><code>def to_iso8601(d: DateLike) -&gt; str:\n    \"\"\"Normalize any date-like input to an ISO8601 string.\n\n    Args:\n        d: Date-like input such as ``str``, ``datetime.date``, or\n            ``datetime.datetime`` (including pandas equivalents).\n\n    Returns:\n        ISO8601 formatted string.\n\n    Raises:\n        TypeError: If the input is not recognized as date-like.\n    \"\"\"\n    if hasattr(d, \"to_pydatetime\"):\n        d = d.to_pydatetime()\n\n    if isinstance(d, str):\n        return d\n    if isinstance(d, datetime):\n        return d.isoformat()\n    if isinstance(d, date):\n        return datetime(d.year, d.month, d.day).isoformat()\n    raise TypeError(f\"Invalid date-like value: {d!r}\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/utils/time/#frequenz.cs_reporting.utils.time.validate_range","title":"frequenz.cs_reporting.utils.time.validate_range","text":"<pre><code>validate_range(\n    start: DateLike, end: DateLike\n) -&gt; tuple[datetime, datetime]\n</code></pre> <p>Validate that the start value precedes the end value.</p> PARAMETER DESCRIPTION <code>start</code> <p>Start date or datetime value.</p> <p> TYPE: <code>DateLike</code> </p> <code>end</code> <p>End date or datetime value.</p> <p> TYPE: <code>DateLike</code> </p> RETURNS DESCRIPTION <code>tuple[datetime, datetime]</code> <p>Original <code>start</code> and <code>end</code> values when valid.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If <code>start</code> is greater than or equal to <code>end</code>.</p> Source code in <code>src/frequenz/cs_reporting/utils/time.py</code> <pre><code>def validate_range(start: DateLike, end: DateLike) -&gt; tuple[datetime, datetime]:\n    \"\"\"Validate that the start value precedes the end value.\n\n    Args:\n        start: Start date or datetime value.\n        end: End date or datetime value.\n\n    Returns:\n        Original ``start`` and ``end`` values when valid.\n\n    Raises:\n        ValueError: If ``start`` is greater than or equal to ``end``.\n    \"\"\"\n    start_dt = to_datetime(start)\n    end_dt = to_datetime(end)\n    if end_dt &lt;= start_dt:\n        raise ValueError(\"end_date must be after start_date\")\n    return start_dt, end_dt\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/","title":"Index","text":""},{"location":"reference/frequenz/cs_reporting/views/#frequenz.cs_reporting.views","title":"frequenz.cs_reporting.views","text":"<p>Streamlit view utilities and renderers.</p>"},{"location":"reference/frequenz/cs_reporting/views/dashboard/","title":"dashboard","text":""},{"location":"reference/frequenz/cs_reporting/views/dashboard/#frequenz.cs_reporting.views.dashboard","title":"frequenz.cs_reporting.views.dashboard","text":"<p>Dashboard view rendering and master dataframe construction.</p>"},{"location":"reference/frequenz/cs_reporting/views/dashboard/#frequenz.cs_reporting.views.dashboard-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/views/dashboard/#frequenz.cs_reporting.views.dashboard-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/views/dashboard/#frequenz.cs_reporting.views.dashboard.build_master_df","title":"frequenz.cs_reporting.views.dashboard.build_master_df","text":"<pre><code>build_master_df(\n    raw_df: DataFrame,\n    component_types: Iterable[str],\n    mcfg: Any,\n    mapper: ColumnMapper,\n) -&gt; DataFrame\n</code></pre> <p>Transform raw microgrid data into master analysis dataframe.</p> <p>Processes raw time-series data from the microgrid to create a comprehensive master dataframe suitable for analysis and visualization. Applies data cleaning, component aggregation, and column mapping.</p> PARAMETER DESCRIPTION <code>raw_df</code> <p>Raw dataframe with microgrid time-series data. Expected columns include timestamp, component IDs, and power/energy measurements.</p> <p> TYPE: <code>DataFrame</code> </p> <code>component_types</code> <p>List of component type strings to include in analysis (e.g., ['pv', 'battery', 'grid']).</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>mcfg</code> <p>Microgrid configuration object containing component metadata and site-specific settings.</p> <p> TYPE: <code>Any</code> </p> <code>mapper</code> <p>Column name mapper for converting internal names to display names.</p> <p> TYPE: <code>ColumnMapper</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Master dataframe with processed and aggregated component data, ready for</p> <code>DataFrame</code> <p>analysis and visualization. Includes derived metrics and standardized</p> <code>DataFrame</code> <p>column names.</p> Source code in <code>src/frequenz/cs_reporting/views/dashboard.py</code> <pre><code>def build_master_df(\n    raw_df: pd.DataFrame,\n    component_types: Iterable[str],\n    mcfg: Any,\n    mapper: ColumnMapper,\n) -&gt; pd.DataFrame:\n    \"\"\"Transform raw microgrid data into master analysis dataframe.\n\n    Processes raw time-series data from the microgrid to create a comprehensive\n    master dataframe suitable for analysis and visualization. Applies data cleaning,\n    component aggregation, and column mapping.\n\n    Args:\n        raw_df: Raw dataframe with microgrid time-series data. Expected columns\n            include timestamp, component IDs, and power/energy measurements.\n        component_types: List of component type strings to include in analysis\n            (e.g., ['pv', 'battery', 'grid']).\n        mcfg: Microgrid configuration object containing component metadata and\n            site-specific settings.\n        mapper: Column name mapper for converting internal names to display names.\n\n    Returns:\n        Master dataframe with processed and aggregated component data, ready for\n        analysis and visualization. Includes derived metrics and standardized\n        column names.\n    \"\"\"\n    if \"consumption\" not in raw_df.columns:\n        raw_df[\"consumption\"] = (\n            raw_df.get(\"grid\", 0) - raw_df.get(\"chp\", 0) - raw_df.get(\"wind\", 0)\n        )\n    component_types = [col for col in component_types if col in raw_df.columns]\n\n    # Now drop components whose meters sum to zero\n    component_types = [\n        c\n        for c in component_types\n        if pd.to_numeric(raw_df[c], errors=\"coerce\").fillna(0).sum() != 0\n    ]\n\n    master_df = create_energy_report_df(raw_df, component_types, mcfg, mapper)\n    return master_df\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/dashboard/#frequenz.cs_reporting.views.dashboard.render_dashboard","title":"frequenz.cs_reporting.views.dashboard.render_dashboard","text":"<pre><code>render_dashboard(\n    master_df: DataFrame,\n    resolution: timedelta,\n    component_types: Iterable[str],\n    mapper: ColumnMapper,\n) -&gt; None\n</code></pre> <p>Render the complete microgrid monitoring dashboard.</p> <p>Displays a comprehensive three-section dashboard: 1. Overview section with summary metric boxes 2. Interactive plots section with time series and pie charts 3. Data tables section with detailed component breakdowns</p> PARAMETER DESCRIPTION <code>master_df</code> <p>Master dataframe containing processed microgrid data with all component measurements and derived metrics.</p> <p> TYPE: <code>DataFrame</code> </p> <code>resolution</code> <p>Time resolution for data aggregation (e.g., timedelta(minutes=15)).</p> <p> TYPE: <code>timedelta</code> </p> <code>component_types</code> <p>List of component types present in the microgrid for dynamic tab generation.</p> <p> TYPE: <code>Iterable[str]</code> </p> <code>mapper</code> <p>Column name mapper for display name standardization.</p> <p> TYPE: <code>ColumnMapper</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Renders Streamlit components directly to the app interface.</p> Note <p>This function orchestrates the dashboard layout and delegates rendering to specialized section modules (summary_boxes, plots_tabs, data_tabs).</p> Source code in <code>src/frequenz/cs_reporting/views/dashboard.py</code> <pre><code>def render_dashboard(\n    master_df: pd.DataFrame,\n    resolution: timedelta,\n    component_types: Iterable[str],\n    mapper: ColumnMapper,\n) -&gt; None:\n    \"\"\"Render the complete microgrid monitoring dashboard.\n\n    Displays a comprehensive three-section dashboard:\n    1. Overview section with summary metric boxes\n    2. Interactive plots section with time series and pie charts\n    3. Data tables section with detailed component breakdowns\n\n    Args:\n        master_df: Master dataframe containing processed microgrid data with all\n            component measurements and derived metrics.\n        resolution: Time resolution for data aggregation (e.g., timedelta(minutes=15)).\n        component_types: List of component types present in the microgrid for\n            dynamic tab generation.\n        mapper: Column name mapper for display name standardization.\n\n    Returns:\n        Renders Streamlit components directly to the app interface.\n\n    Note:\n        This function orchestrates the dashboard layout and delegates rendering\n        to specialized section modules (summary_boxes, plots_tabs, data_tabs).\n    \"\"\"\n    tables = _build_tables(master_df, resolution, component_types)\n\n    # --- Overview section---\n    st.markdown(\"&lt;hr style='border: 1px dotted #bbb;'&gt;\", unsafe_allow_html=True)\n    sections.render_summary_boxes(tables[\"metrics\"])\n\n    # --- Plots section---\n    st.markdown(\n        \"&lt;hr style='border:1px solid #ddd; margin:20px 0;'&gt;\", unsafe_allow_html=True\n    )\n    sections.render_plots_tabs(tables, mapper)\n\n    # --- Tables section---\n    st.markdown(\"&lt;hr style='border: 1px dotted #bbb;'&gt;\", unsafe_allow_html=True)\n    sections.render_data_tabs(master_df, tables)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/metric_renderers/","title":"metric_renderers","text":""},{"location":"reference/frequenz/cs_reporting/views/metric_renderers/#frequenz.cs_reporting.views.metric_renderers","title":"frequenz.cs_reporting.views.metric_renderers","text":"<p>Metric rendering functions for the reporting views.</p>"},{"location":"reference/frequenz/cs_reporting/views/metric_renderers/#frequenz.cs_reporting.views.metric_renderers-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/views/metric_renderers/#frequenz.cs_reporting.views.metric_renderers.render_box_grid","title":"frequenz.cs_reporting.views.metric_renderers.render_box_grid","text":"<pre><code>render_box_grid(\n    boxes: list[tuple[str, object]],\n    per_row: int = 3,\n    row_gap: int = 20,\n) -&gt; None\n</code></pre> <p>Render boxes in a grid layout.</p> PARAMETER DESCRIPTION <code>boxes</code> <p>Prepared list of label/value tuples.</p> <p> TYPE: <code>list[tuple[str, object]]</code> </p> <code>per_row</code> <p>Maximum number of boxes to render per row.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>row_gap</code> <p>Vertical gap between rows in pixels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit markup is written directly to the page.</p> Source code in <code>src/frequenz/cs_reporting/views/metric_renderers.py</code> <pre><code>def render_box_grid(\n    boxes: list[tuple[str, object]], per_row: int = 3, row_gap: int = 20\n) -&gt; None:\n    \"\"\"Render boxes in a grid layout.\n\n    Args:\n        boxes: Prepared list of label/value tuples.\n        per_row: Maximum number of boxes to render per row.\n        row_gap: Vertical gap between rows in pixels.\n\n    Returns:\n        Streamlit markup is written directly to the page.\n    \"\"\"\n    for i in range(0, len(boxes), per_row):\n        row = boxes[i : i + per_row]\n\n        # pad row with empty boxes so it always has `per_row` items\n        while len(row) &lt; per_row:\n            row.append((\"\", None))\n\n        cols = st.columns(per_row, gap=\"medium\")\n        for col, (label, val) in zip(cols, row):\n            if label == \"\" and val is None:\n                # render transparent placeholder\n                col.markdown(\n                    \"\"\"\n                    &lt;div style=\"\n                        background:transparent;\n                        border:1px solid transparent;\n                        border-radius:8px;\n                        padding:14px;\n                        text-align:center;\n                    \"&gt;&amp;nbsp;&lt;/div&gt;\n                    \"\"\",\n                    unsafe_allow_html=True,\n                )\n            else:\n                txt = (\n                    \"-\"\n                    if val is None\n                    else (f\"{val:,.2f}\" if isinstance(val, (int, float)) else str(val))\n                )\n                col.markdown(\n                    f\"\"\"\n                    &lt;div style=\"\n                        background:#f9f9f9;\n                        border:1px solid #ddd;\n                        border-radius:8px;\n                        padding:14px;\n                        text-align:center;\n                        box-shadow:1px 1px 3px rgba(0,0,0,0.06);\n                    \"&gt;\n                        &lt;div style=\"font-size:13px;color:#555;\"&gt;{label}&lt;/div&gt;\n                        &lt;div style=\"font-size:20px;font-weight:700;color:#1565c0;\"&gt;{txt}&lt;/div&gt;\n                    &lt;/div&gt;\n                    \"\"\",\n                    unsafe_allow_html=True,\n                )\n\n        # add vertical gap between rows (except last)\n        if i + per_row &lt; len(boxes):\n            st.markdown(\n                f\"&lt;div style='margin-top:{row_gap}px;'&gt;&lt;/div&gt;\", unsafe_allow_html=True\n            )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/metric_renderers/#frequenz.cs_reporting.views.metric_renderers.render_summary_boxes","title":"frequenz.cs_reporting.views.metric_renderers.render_summary_boxes","text":"<pre><code>render_summary_boxes(metrics: dict[str, Any]) -&gt; None\n</code></pre> <p>Render overview metrics grouped into subsections.</p> PARAMETER DESCRIPTION <code>metrics</code> <p>Metrics dictionary containing aggregated KPI values.</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/metric_renderers.py</code> <pre><code>def render_summary_boxes(metrics: dict[str, Any]) -&gt; None:\n    \"\"\"Render overview metrics grouped into subsections.\n\n    Args:\n        metrics: Metrics dictionary containing aggregated KPI values.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if not metrics:\n        st.info(\"No overview metrics available.\")\n        return\n\n    st.subheader(\"\u00dcbersicht\")\n\n    for section in SECTION_SPECS:\n        st.markdown(f\"##### {section['title']}\")\n        boxes = _materialize_boxes(section[\"boxes\"], metrics)\n        render_box_grid(boxes)\n\n    consumption_dict = _build_consumption_breakdown(metrics)\n    consumption_bar_plot = plot_percentage_bar(\n        consumption_dict, total_key=\"Stromverbrauch (kWh)\"\n    )\n    st.plotly_chart(consumption_bar_plot, width=\"stretch\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/","title":"plot_renderers","text":""},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/#frequenz.cs_reporting.views.plot_renderers","title":"frequenz.cs_reporting.views.plot_renderers","text":"<p>Plot rendering functions for the reporting views.</p>"},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/#frequenz.cs_reporting.views.plot_renderers-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/#frequenz.cs_reporting.views.plot_renderers-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/#frequenz.cs_reporting.views.plot_renderers.render_energy_pie_chart","title":"frequenz.cs_reporting.views.plot_renderers.render_energy_pie_chart","text":"<pre><code>render_energy_pie_chart(\n    power_df: DataFrame | None,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>Render the energy mix pie chart from a power dataframe.</p> PARAMETER DESCRIPTION <code>power_df</code> <p>Dataframe containing <code>Energy Source</code> and <code>Energy [kWh]</code>.</p> <p> TYPE: <code>DataFrame | None</code> </p> <code>color_dict</code> <p>Optional color mapping for pie segments.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/plot_renderers.py</code> <pre><code>def render_energy_pie_chart(\n    power_df: pd.DataFrame | None,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Render the energy mix pie chart from a power dataframe.\n\n    Args:\n        power_df: Dataframe containing ``Energy Source`` and ``Energy [kWh]``.\n        color_dict: Optional color mapping for pie segments.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if power_df is None or power_df.empty:\n        st.info(\"No data available for energy pie chart.\")\n        return\n\n    required_cols = {\"Energy Source\", \"Energy [kWh]\"}\n    if not required_cols.issubset(set(power_df.columns)):\n        st.info(\"Energy data missing required columns.\")\n        return\n\n    power_df[\"Energy Source\"] = power_df[\"Energy Source\"].replace(\n        {\"CHP\": \"BHKW\", \"Grid Consumption\": \"Netzbezug\"}\n    )\n    power_df = power_df.rename(\n        columns={\"Energy Source\": \"Energiebezug\", \"Energy [kWh]\": \"Energie [kWh]\"}\n    )\n    fig = plot_energy_pie_chart(power_df, color_dict=color_dict)\n    render_plot_card(\"Energie-Mix\", fig)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/#frequenz.cs_reporting.views.plot_renderers.render_plots_tabs","title":"frequenz.cs_reporting.views.plot_renderers.render_plots_tabs","text":"<pre><code>render_plots_tabs(\n    tables: TablesResult,\n    mapper: ColumnMapper,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>Render the plots section with overview, pie chart, and component tabs.</p> PARAMETER DESCRIPTION <code>tables</code> <p>Dictionary of analysis tables including overview and component analysis dataframes.</p> <p> TYPE: <code>TablesResult</code> </p> <code>mapper</code> <p>Column mapper for display naming.</p> <p> TYPE: <code>ColumnMapper</code> </p> <code>color_dict</code> <p>Optional color mapping used across plots.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/plot_renderers.py</code> <pre><code>def render_plots_tabs(\n    tables: TablesResult,\n    mapper: ColumnMapper,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Render the plots section with overview, pie chart, and component tabs.\n\n    Args:\n        tables: Dictionary of analysis tables including overview and component\n            analysis dataframes.\n        mapper: Column mapper for display naming.\n        color_dict: Optional color mapping used across plots.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    st.subheader(\"Plots\")\n\n    palette = color_dict or COLOR_DICT\n    overview_df = _prepare_overview_df(tables, mapper)\n\n    tab_labels = [\"Zeitreihen-Plot\", \"Energie-Mix\"] + [\n        label for label, _ in _COMPONENT_TABS\n    ]\n    plot_tabs = st.tabs(tab_labels)\n\n    with plot_tabs[0]:\n        _render_overview_plot(overview_df, palette)\n\n    with plot_tabs[1]:\n        render_energy_pie_chart(tables.get(\"power_table\"), color_dict=palette)\n\n    for tab, (_, key) in zip(plot_tabs[2:], _COMPONENT_TABS):\n        with tab:\n            config = COMPONENT_CONFIGS.get(key)\n            if not config:\n                st.info(\"Keine Konfiguration f\u00fcr diese Komponente.\")\n                continue\n            _render_component_tab(\n                tables=tables,\n                mapper=mapper,\n                table_key=f\"{key}_analysis\",\n                title=config[\"title\"],\n                category_col=config[\"label\"],\n                value_col=config[\"value_col\"],\n                color_dict=palette,\n            )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/plot_renderers/#frequenz.cs_reporting.views.plot_renderers.render_time_series","title":"frequenz.cs_reporting.views.plot_renderers.render_time_series","text":"<pre><code>render_time_series(\n    df: DataFrame,\n    *,\n    time_col: str = \"Zeitpunkt\",\n    cols: list[str] | None = None,\n    title: str = \"Zeitreihen-Plot\",\n    xaxis_title: str = \"Zeitpunkt\",\n    yaxis_title: str = \"kWh\",\n    legend_title: str | None = \"Komponenten\",\n    color_dict: dict[str, str] | None = None,\n    long_format_flag: bool = False,\n    category_col: str | None = None,\n    value_col: str | None = None,\n    fill_cols: list[str] | None = None,\n    plot_order: list[str] | None = None\n) -&gt; None\n</code></pre> <p>Render a generic time-series plot inside a card.</p> PARAMETER DESCRIPTION <code>df</code> <p>Dataframe containing a datetime column and series to plot.</p> <p> TYPE: <code>DataFrame</code> </p> <code>time_col</code> <p>Column name containing datetime values.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Zeitpunkt'</code> </p> <code>cols</code> <p>Optional list of series columns to include; defaults to all non-time columns.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Title displayed above the plot.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Zeitreihen-Plot'</code> </p> <code>xaxis_title</code> <p>X-axis label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Zeitpunkt'</code> </p> <code>yaxis_title</code> <p>Y-axis label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'kWh'</code> </p> <code>legend_title</code> <p>Legend title or <code>None</code> to hide the legend title.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>'Komponenten'</code> </p> <code>color_dict</code> <p>Optional mapping from column names to colors.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> <code>long_format_flag</code> <p>Whether the dataframe is already in long format.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>category_col</code> <p>Category column name when <code>long_format_flag</code> is <code>True</code>.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>value_col</code> <p>Value column name when <code>long_format_flag</code> is <code>True</code>.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>fill_cols</code> <p>Columns to fill under the curve for stacked plots.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>plot_order</code> <p>Explicit ordering of series when rendering.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/plot_renderers.py</code> <pre><code>def render_time_series(\n    df: pd.DataFrame,\n    *,\n    time_col: str = \"Zeitpunkt\",\n    cols: list[str] | None = None,\n    title: str = \"Zeitreihen-Plot\",\n    xaxis_title: str = \"Zeitpunkt\",\n    yaxis_title: str = \"kWh\",\n    legend_title: str | None = \"Komponenten\",\n    color_dict: dict[str, str] | None = None,\n    long_format_flag: bool = False,\n    category_col: str | None = None,\n    value_col: str | None = None,\n    fill_cols: list[str] | None = None,\n    plot_order: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Render a generic time-series plot inside a card.\n\n    Args:\n        df: Dataframe containing a datetime column and series to plot.\n        time_col: Column name containing datetime values.\n        cols: Optional list of series columns to include; defaults to all\n            non-time columns.\n        title: Title displayed above the plot.\n        xaxis_title: X-axis label.\n        yaxis_title: Y-axis label.\n        legend_title: Legend title or ``None`` to hide the legend title.\n        color_dict: Optional mapping from column names to colors.\n        long_format_flag: Whether the dataframe is already in long format.\n        category_col: Category column name when ``long_format_flag`` is ``True``.\n        value_col: Value column name when ``long_format_flag`` is ``True``.\n        fill_cols: Columns to fill under the curve for stacked plots.\n        plot_order: Explicit ordering of series when rendering.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if df is None or df.empty:\n        st.info(\"No data to plot.\")\n        return\n\n    if time_col not in df.columns:\n        st.info(f\"No valid time column found (expected '{time_col}').\")\n        return\n\n    df = df.copy()\n    if not pd.api.types.is_datetime64_any_dtype(df[time_col]):\n        df[time_col] = pd.to_datetime(df[time_col], errors=\"coerce\")\n\n    fig = plot_time_series(\n        df,\n        time_col=time_col,\n        cols=cols,\n        title=title,\n        xaxis_title=xaxis_title,\n        yaxis_title=yaxis_title,\n        legend_title=legend_title,\n        color_dict=color_dict,\n        long_format_flag=long_format_flag,\n        category_col=category_col,\n        value_col=value_col,\n        fill_cols=fill_cols,\n        plot_order=plot_order,\n    )\n\n    render_plot_card(title, fig)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/","title":"sections","text":""},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections","title":"frequenz.cs_reporting.views.sections","text":"<p>Reporting views sections - facade module for backward compatibility.</p> <p>This module re-exports rendering functions from specialized modules: - table_renderers: Table rendering functions - plot_renderers: Plot rendering functions - metric_renderers: Metric box rendering functions</p>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_box_grid","title":"frequenz.cs_reporting.views.sections.render_box_grid","text":"<pre><code>render_box_grid(\n    boxes: list[tuple[str, object]],\n    per_row: int = 3,\n    row_gap: int = 20,\n) -&gt; None\n</code></pre> <p>Render boxes in a grid layout.</p> PARAMETER DESCRIPTION <code>boxes</code> <p>Prepared list of label/value tuples.</p> <p> TYPE: <code>list[tuple[str, object]]</code> </p> <code>per_row</code> <p>Maximum number of boxes to render per row.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>row_gap</code> <p>Vertical gap between rows in pixels.</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit markup is written directly to the page.</p> Source code in <code>src/frequenz/cs_reporting/views/metric_renderers.py</code> <pre><code>def render_box_grid(\n    boxes: list[tuple[str, object]], per_row: int = 3, row_gap: int = 20\n) -&gt; None:\n    \"\"\"Render boxes in a grid layout.\n\n    Args:\n        boxes: Prepared list of label/value tuples.\n        per_row: Maximum number of boxes to render per row.\n        row_gap: Vertical gap between rows in pixels.\n\n    Returns:\n        Streamlit markup is written directly to the page.\n    \"\"\"\n    for i in range(0, len(boxes), per_row):\n        row = boxes[i : i + per_row]\n\n        # pad row with empty boxes so it always has `per_row` items\n        while len(row) &lt; per_row:\n            row.append((\"\", None))\n\n        cols = st.columns(per_row, gap=\"medium\")\n        for col, (label, val) in zip(cols, row):\n            if label == \"\" and val is None:\n                # render transparent placeholder\n                col.markdown(\n                    \"\"\"\n                    &lt;div style=\"\n                        background:transparent;\n                        border:1px solid transparent;\n                        border-radius:8px;\n                        padding:14px;\n                        text-align:center;\n                    \"&gt;&amp;nbsp;&lt;/div&gt;\n                    \"\"\",\n                    unsafe_allow_html=True,\n                )\n            else:\n                txt = (\n                    \"-\"\n                    if val is None\n                    else (f\"{val:,.2f}\" if isinstance(val, (int, float)) else str(val))\n                )\n                col.markdown(\n                    f\"\"\"\n                    &lt;div style=\"\n                        background:#f9f9f9;\n                        border:1px solid #ddd;\n                        border-radius:8px;\n                        padding:14px;\n                        text-align:center;\n                        box-shadow:1px 1px 3px rgba(0,0,0,0.06);\n                    \"&gt;\n                        &lt;div style=\"font-size:13px;color:#555;\"&gt;{label}&lt;/div&gt;\n                        &lt;div style=\"font-size:20px;font-weight:700;color:#1565c0;\"&gt;{txt}&lt;/div&gt;\n                    &lt;/div&gt;\n                    \"\"\",\n                    unsafe_allow_html=True,\n                )\n\n        # add vertical gap between rows (except last)\n        if i + per_row &lt; len(boxes):\n            st.markdown(\n                f\"&lt;div style='margin-top:{row_gap}px;'&gt;&lt;/div&gt;\", unsafe_allow_html=True\n            )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_data_tabs","title":"frequenz.cs_reporting.views.sections.render_data_tabs","text":"<pre><code>render_data_tabs(\n    master_df: DataFrame, tables_dict: TablesResult\n) -&gt; None\n</code></pre> <p>Render tabbed data tables for overview and component analyses.</p> PARAMETER DESCRIPTION <code>master_df</code> <p>Processed master dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> <code>tables_dict</code> <p>Mapping of table names to dataframes for each analysis.</p> <p> TYPE: <code>TablesResult</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/table_renderers.py</code> <pre><code>def render_data_tabs(master_df: pd.DataFrame, tables_dict: TablesResult) -&gt; None:\n    \"\"\"Render tabbed data tables for overview and component analyses.\n\n    Args:\n        master_df: Processed master dataframe.\n        tables_dict: Mapping of table names to dataframes for each analysis.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    st.subheader(\"Data Tables\")\n\n    tab_labels = [spec[\"label\"] for spec in TABLE_TAB_SPECS] + [\"Combined DF\"]\n    tabs = st.tabs(tab_labels)\n\n    for tab, spec in zip(tabs[:-1], TABLE_TAB_SPECS):\n        value = tables_dict.get(spec[\"table_key\"])\n        with tab:\n            render_table_section(\n                value if isinstance(value, pd.DataFrame) else None,\n                key_prefix=spec[\"key_prefix\"],\n                caption=spec.get(\"caption\"),\n                empty_info=spec.get(\"empty_info\"),\n            )\n\n    with tabs[-1]:\n        render_master_df(master_df)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_energy_pie_chart","title":"frequenz.cs_reporting.views.sections.render_energy_pie_chart","text":"<pre><code>render_energy_pie_chart(\n    power_df: DataFrame | None,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>Render the energy mix pie chart from a power dataframe.</p> PARAMETER DESCRIPTION <code>power_df</code> <p>Dataframe containing <code>Energy Source</code> and <code>Energy [kWh]</code>.</p> <p> TYPE: <code>DataFrame | None</code> </p> <code>color_dict</code> <p>Optional color mapping for pie segments.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/plot_renderers.py</code> <pre><code>def render_energy_pie_chart(\n    power_df: pd.DataFrame | None,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Render the energy mix pie chart from a power dataframe.\n\n    Args:\n        power_df: Dataframe containing ``Energy Source`` and ``Energy [kWh]``.\n        color_dict: Optional color mapping for pie segments.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if power_df is None or power_df.empty:\n        st.info(\"No data available for energy pie chart.\")\n        return\n\n    required_cols = {\"Energy Source\", \"Energy [kWh]\"}\n    if not required_cols.issubset(set(power_df.columns)):\n        st.info(\"Energy data missing required columns.\")\n        return\n\n    power_df[\"Energy Source\"] = power_df[\"Energy Source\"].replace(\n        {\"CHP\": \"BHKW\", \"Grid Consumption\": \"Netzbezug\"}\n    )\n    power_df = power_df.rename(\n        columns={\"Energy Source\": \"Energiebezug\", \"Energy [kWh]\": \"Energie [kWh]\"}\n    )\n    fig = plot_energy_pie_chart(power_df, color_dict=color_dict)\n    render_plot_card(\"Energie-Mix\", fig)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_master_df","title":"frequenz.cs_reporting.views.sections.render_master_df","text":"<pre><code>render_master_df(master_df: DataFrame) -&gt; None\n</code></pre> <p>Render the combined master dataframe in an AgGrid table.</p> PARAMETER DESCRIPTION <code>master_df</code> <p>Processed master dataframe to display.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/table_renderers.py</code> <pre><code>def render_master_df(master_df: pd.DataFrame) -&gt; None:\n    \"\"\"Render the combined master dataframe in an AgGrid table.\n\n    Args:\n        master_df: Processed master dataframe to display.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if master_df is not None and not master_df.empty:\n        header_cols = st.columns([10, 1])\n        header_cols[0].caption(\"Standardized master dataframe\")\n        display_df = _round_numeric_columns(master_df)\n        master_csv = display_df.to_csv(index=False).encode(\"utf-8\")\n        _style_download_button(header_cols[1])\n        header_cols[1].download_button(\n            label=\"Download combined dataframe\",\n            data=master_csv,\n            file_name=\"master_df.csv\",\n            mime=\"text/csv\",\n            key=\"master_df_download\",\n        )\n        tables.aggrid_table(\n            display_df,\n            key_prefix=\"master_df\",\n        )\n    else:\n        st.info(\"Master DF unavailable (no MicrogridConfig).\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_plots_tabs","title":"frequenz.cs_reporting.views.sections.render_plots_tabs","text":"<pre><code>render_plots_tabs(\n    tables: TablesResult,\n    mapper: ColumnMapper,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None\n</code></pre> <p>Render the plots section with overview, pie chart, and component tabs.</p> PARAMETER DESCRIPTION <code>tables</code> <p>Dictionary of analysis tables including overview and component analysis dataframes.</p> <p> TYPE: <code>TablesResult</code> </p> <code>mapper</code> <p>Column mapper for display naming.</p> <p> TYPE: <code>ColumnMapper</code> </p> <code>color_dict</code> <p>Optional color mapping used across plots.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/plot_renderers.py</code> <pre><code>def render_plots_tabs(\n    tables: TablesResult,\n    mapper: ColumnMapper,\n    color_dict: dict[str, str] | None = None,\n) -&gt; None:\n    \"\"\"Render the plots section with overview, pie chart, and component tabs.\n\n    Args:\n        tables: Dictionary of analysis tables including overview and component\n            analysis dataframes.\n        mapper: Column mapper for display naming.\n        color_dict: Optional color mapping used across plots.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    st.subheader(\"Plots\")\n\n    palette = color_dict or COLOR_DICT\n    overview_df = _prepare_overview_df(tables, mapper)\n\n    tab_labels = [\"Zeitreihen-Plot\", \"Energie-Mix\"] + [\n        label for label, _ in _COMPONENT_TABS\n    ]\n    plot_tabs = st.tabs(tab_labels)\n\n    with plot_tabs[0]:\n        _render_overview_plot(overview_df, palette)\n\n    with plot_tabs[1]:\n        render_energy_pie_chart(tables.get(\"power_table\"), color_dict=palette)\n\n    for tab, (_, key) in zip(plot_tabs[2:], _COMPONENT_TABS):\n        with tab:\n            config = COMPONENT_CONFIGS.get(key)\n            if not config:\n                st.info(\"Keine Konfiguration f\u00fcr diese Komponente.\")\n                continue\n            _render_component_tab(\n                tables=tables,\n                mapper=mapper,\n                table_key=f\"{key}_analysis\",\n                title=config[\"title\"],\n                category_col=config[\"label\"],\n                value_col=config[\"value_col\"],\n                color_dict=palette,\n            )\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_summary_boxes","title":"frequenz.cs_reporting.views.sections.render_summary_boxes","text":"<pre><code>render_summary_boxes(metrics: dict[str, Any]) -&gt; None\n</code></pre> <p>Render overview metrics grouped into subsections.</p> PARAMETER DESCRIPTION <code>metrics</code> <p>Metrics dictionary containing aggregated KPI values.</p> <p> TYPE: <code>dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/metric_renderers.py</code> <pre><code>def render_summary_boxes(metrics: dict[str, Any]) -&gt; None:\n    \"\"\"Render overview metrics grouped into subsections.\n\n    Args:\n        metrics: Metrics dictionary containing aggregated KPI values.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if not metrics:\n        st.info(\"No overview metrics available.\")\n        return\n\n    st.subheader(\"\u00dcbersicht\")\n\n    for section in SECTION_SPECS:\n        st.markdown(f\"##### {section['title']}\")\n        boxes = _materialize_boxes(section[\"boxes\"], metrics)\n        render_box_grid(boxes)\n\n    consumption_dict = _build_consumption_breakdown(metrics)\n    consumption_bar_plot = plot_percentage_bar(\n        consumption_dict, total_key=\"Stromverbrauch (kWh)\"\n    )\n    st.plotly_chart(consumption_bar_plot, width=\"stretch\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_table_section","title":"frequenz.cs_reporting.views.sections.render_table_section","text":"<pre><code>render_table_section(\n    df: DataFrame | None,\n    *,\n    key_prefix: str,\n    caption: str | None = None,\n    empty_info: str | None = None\n) -&gt; None\n</code></pre> <p>Render a captioned AgGrid table, safely handling None/empty data.</p> PARAMETER DESCRIPTION <code>df</code> <p>The dataframe to display. If <code>None</code> or empty, an empty table is shown and an optional info message is rendered.</p> <p> TYPE: <code>DataFrame | None</code> </p> <code>key_prefix</code> <p>Unique key prefix for the grid instance (used by Streamlit state).</p> <p> TYPE: <code>str</code> </p> <code>caption</code> <p>Optional caption shown above the table.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>empty_info</code> <p>Optional info message to show when <code>df</code> is <code>None</code> or empty.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/table_renderers.py</code> <pre><code>def render_table_section(\n    df: pd.DataFrame | None,\n    *,\n    key_prefix: str,\n    caption: str | None = None,\n    empty_info: str | None = None,\n) -&gt; None:\n    \"\"\"Render a captioned AgGrid table, safely handling None/empty data.\n\n    Args:\n        df: The dataframe to display. If ``None`` or empty, an empty table is shown\n            and an optional info message is rendered.\n        key_prefix: Unique key prefix for the grid instance (used by Streamlit state).\n        caption: Optional caption shown above the table.\n        empty_info: Optional info message to show when ``df`` is ``None`` or empty.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    safe_df = df if (df is not None and not df.empty) else pd.DataFrame()\n    display_df = _round_numeric_columns(safe_df)\n    header_cols = st.columns([8, 1])\n    if caption:\n        header_cols[0].caption(caption)\n    else:\n        header_cols[0].markdown(\"\", unsafe_allow_html=True)\n\n    if not safe_df.empty:\n        csv_bytes = display_df.to_csv(index=False).encode(\"utf-8\")\n        _style_download_button(header_cols[1])\n        header_cols[1].download_button(\n            label=\"Download table CSV\",\n            data=csv_bytes,\n            file_name=f\"{key_prefix}.csv\",\n            mime=\"text/csv\",\n            key=f\"{key_prefix}_download\",\n        )\n\n    tables.aggrid_table(display_df, key_prefix=key_prefix)\n\n    if (df is None or df.empty) and empty_info:\n        st.info(empty_info)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/sections/#frequenz.cs_reporting.views.sections.render_time_series","title":"frequenz.cs_reporting.views.sections.render_time_series","text":"<pre><code>render_time_series(\n    df: DataFrame,\n    *,\n    time_col: str = \"Zeitpunkt\",\n    cols: list[str] | None = None,\n    title: str = \"Zeitreihen-Plot\",\n    xaxis_title: str = \"Zeitpunkt\",\n    yaxis_title: str = \"kWh\",\n    legend_title: str | None = \"Komponenten\",\n    color_dict: dict[str, str] | None = None,\n    long_format_flag: bool = False,\n    category_col: str | None = None,\n    value_col: str | None = None,\n    fill_cols: list[str] | None = None,\n    plot_order: list[str] | None = None\n) -&gt; None\n</code></pre> <p>Render a generic time-series plot inside a card.</p> PARAMETER DESCRIPTION <code>df</code> <p>Dataframe containing a datetime column and series to plot.</p> <p> TYPE: <code>DataFrame</code> </p> <code>time_col</code> <p>Column name containing datetime values.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Zeitpunkt'</code> </p> <code>cols</code> <p>Optional list of series columns to include; defaults to all non-time columns.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Title displayed above the plot.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Zeitreihen-Plot'</code> </p> <code>xaxis_title</code> <p>X-axis label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'Zeitpunkt'</code> </p> <code>yaxis_title</code> <p>Y-axis label.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'kWh'</code> </p> <code>legend_title</code> <p>Legend title or <code>None</code> to hide the legend title.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>'Komponenten'</code> </p> <code>color_dict</code> <p>Optional mapping from column names to colors.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> <code>long_format_flag</code> <p>Whether the dataframe is already in long format.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>category_col</code> <p>Category column name when <code>long_format_flag</code> is <code>True</code>.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>value_col</code> <p>Value column name when <code>long_format_flag</code> is <code>True</code>.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>fill_cols</code> <p>Columns to fill under the curve for stacked plots.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>plot_order</code> <p>Explicit ordering of series when rendering.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/plot_renderers.py</code> <pre><code>def render_time_series(\n    df: pd.DataFrame,\n    *,\n    time_col: str = \"Zeitpunkt\",\n    cols: list[str] | None = None,\n    title: str = \"Zeitreihen-Plot\",\n    xaxis_title: str = \"Zeitpunkt\",\n    yaxis_title: str = \"kWh\",\n    legend_title: str | None = \"Komponenten\",\n    color_dict: dict[str, str] | None = None,\n    long_format_flag: bool = False,\n    category_col: str | None = None,\n    value_col: str | None = None,\n    fill_cols: list[str] | None = None,\n    plot_order: list[str] | None = None,\n) -&gt; None:\n    \"\"\"Render a generic time-series plot inside a card.\n\n    Args:\n        df: Dataframe containing a datetime column and series to plot.\n        time_col: Column name containing datetime values.\n        cols: Optional list of series columns to include; defaults to all\n            non-time columns.\n        title: Title displayed above the plot.\n        xaxis_title: X-axis label.\n        yaxis_title: Y-axis label.\n        legend_title: Legend title or ``None`` to hide the legend title.\n        color_dict: Optional mapping from column names to colors.\n        long_format_flag: Whether the dataframe is already in long format.\n        category_col: Category column name when ``long_format_flag`` is ``True``.\n        value_col: Value column name when ``long_format_flag`` is ``True``.\n        fill_cols: Columns to fill under the curve for stacked plots.\n        plot_order: Explicit ordering of series when rendering.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if df is None or df.empty:\n        st.info(\"No data to plot.\")\n        return\n\n    if time_col not in df.columns:\n        st.info(f\"No valid time column found (expected '{time_col}').\")\n        return\n\n    df = df.copy()\n    if not pd.api.types.is_datetime64_any_dtype(df[time_col]):\n        df[time_col] = pd.to_datetime(df[time_col], errors=\"coerce\")\n\n    fig = plot_time_series(\n        df,\n        time_col=time_col,\n        cols=cols,\n        title=title,\n        xaxis_title=xaxis_title,\n        yaxis_title=yaxis_title,\n        legend_title=legend_title,\n        color_dict=color_dict,\n        long_format_flag=long_format_flag,\n        category_col=category_col,\n        value_col=value_col,\n        fill_cols=fill_cols,\n        plot_order=plot_order,\n    )\n\n    render_plot_card(title, fig)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/table_renderers/","title":"table_renderers","text":""},{"location":"reference/frequenz/cs_reporting/views/table_renderers/#frequenz.cs_reporting.views.table_renderers","title":"frequenz.cs_reporting.views.table_renderers","text":"<p>Table rendering functions for the reporting views.</p>"},{"location":"reference/frequenz/cs_reporting/views/table_renderers/#frequenz.cs_reporting.views.table_renderers-classes","title":"Classes","text":""},{"location":"reference/frequenz/cs_reporting/views/table_renderers/#frequenz.cs_reporting.views.table_renderers-functions","title":"Functions","text":""},{"location":"reference/frequenz/cs_reporting/views/table_renderers/#frequenz.cs_reporting.views.table_renderers.render_data_tabs","title":"frequenz.cs_reporting.views.table_renderers.render_data_tabs","text":"<pre><code>render_data_tabs(\n    master_df: DataFrame, tables_dict: TablesResult\n) -&gt; None\n</code></pre> <p>Render tabbed data tables for overview and component analyses.</p> PARAMETER DESCRIPTION <code>master_df</code> <p>Processed master dataframe.</p> <p> TYPE: <code>DataFrame</code> </p> <code>tables_dict</code> <p>Mapping of table names to dataframes for each analysis.</p> <p> TYPE: <code>TablesResult</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/table_renderers.py</code> <pre><code>def render_data_tabs(master_df: pd.DataFrame, tables_dict: TablesResult) -&gt; None:\n    \"\"\"Render tabbed data tables for overview and component analyses.\n\n    Args:\n        master_df: Processed master dataframe.\n        tables_dict: Mapping of table names to dataframes for each analysis.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    st.subheader(\"Data Tables\")\n\n    tab_labels = [spec[\"label\"] for spec in TABLE_TAB_SPECS] + [\"Combined DF\"]\n    tabs = st.tabs(tab_labels)\n\n    for tab, spec in zip(tabs[:-1], TABLE_TAB_SPECS):\n        value = tables_dict.get(spec[\"table_key\"])\n        with tab:\n            render_table_section(\n                value if isinstance(value, pd.DataFrame) else None,\n                key_prefix=spec[\"key_prefix\"],\n                caption=spec.get(\"caption\"),\n                empty_info=spec.get(\"empty_info\"),\n            )\n\n    with tabs[-1]:\n        render_master_df(master_df)\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/table_renderers/#frequenz.cs_reporting.views.table_renderers.render_master_df","title":"frequenz.cs_reporting.views.table_renderers.render_master_df","text":"<pre><code>render_master_df(master_df: DataFrame) -&gt; None\n</code></pre> <p>Render the combined master dataframe in an AgGrid table.</p> PARAMETER DESCRIPTION <code>master_df</code> <p>Processed master dataframe to display.</p> <p> TYPE: <code>DataFrame</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/table_renderers.py</code> <pre><code>def render_master_df(master_df: pd.DataFrame) -&gt; None:\n    \"\"\"Render the combined master dataframe in an AgGrid table.\n\n    Args:\n        master_df: Processed master dataframe to display.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    if master_df is not None and not master_df.empty:\n        header_cols = st.columns([10, 1])\n        header_cols[0].caption(\"Standardized master dataframe\")\n        display_df = _round_numeric_columns(master_df)\n        master_csv = display_df.to_csv(index=False).encode(\"utf-8\")\n        _style_download_button(header_cols[1])\n        header_cols[1].download_button(\n            label=\"Download combined dataframe\",\n            data=master_csv,\n            file_name=\"master_df.csv\",\n            mime=\"text/csv\",\n            key=\"master_df_download\",\n        )\n        tables.aggrid_table(\n            display_df,\n            key_prefix=\"master_df\",\n        )\n    else:\n        st.info(\"Master DF unavailable (no MicrogridConfig).\")\n</code></pre>"},{"location":"reference/frequenz/cs_reporting/views/table_renderers/#frequenz.cs_reporting.views.table_renderers.render_table_section","title":"frequenz.cs_reporting.views.table_renderers.render_table_section","text":"<pre><code>render_table_section(\n    df: DataFrame | None,\n    *,\n    key_prefix: str,\n    caption: str | None = None,\n    empty_info: str | None = None\n) -&gt; None\n</code></pre> <p>Render a captioned AgGrid table, safely handling None/empty data.</p> PARAMETER DESCRIPTION <code>df</code> <p>The dataframe to display. If <code>None</code> or empty, an empty table is shown and an optional info message is rendered.</p> <p> TYPE: <code>DataFrame | None</code> </p> <code>key_prefix</code> <p>Unique key prefix for the grid instance (used by Streamlit state).</p> <p> TYPE: <code>str</code> </p> <code>caption</code> <p>Optional caption shown above the table.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>empty_info</code> <p>Optional info message to show when <code>df</code> is <code>None</code> or empty.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Streamlit components are rendered directly.</p> Source code in <code>src/frequenz/cs_reporting/views/table_renderers.py</code> <pre><code>def render_table_section(\n    df: pd.DataFrame | None,\n    *,\n    key_prefix: str,\n    caption: str | None = None,\n    empty_info: str | None = None,\n) -&gt; None:\n    \"\"\"Render a captioned AgGrid table, safely handling None/empty data.\n\n    Args:\n        df: The dataframe to display. If ``None`` or empty, an empty table is shown\n            and an optional info message is rendered.\n        key_prefix: Unique key prefix for the grid instance (used by Streamlit state).\n        caption: Optional caption shown above the table.\n        empty_info: Optional info message to show when ``df`` is ``None`` or empty.\n\n    Returns:\n        Streamlit components are rendered directly.\n    \"\"\"\n    safe_df = df if (df is not None and not df.empty) else pd.DataFrame()\n    display_df = _round_numeric_columns(safe_df)\n    header_cols = st.columns([8, 1])\n    if caption:\n        header_cols[0].caption(caption)\n    else:\n        header_cols[0].markdown(\"\", unsafe_allow_html=True)\n\n    if not safe_df.empty:\n        csv_bytes = display_df.to_csv(index=False).encode(\"utf-8\")\n        _style_download_button(header_cols[1])\n        header_cols[1].download_button(\n            label=\"Download table CSV\",\n            data=csv_bytes,\n            file_name=f\"{key_prefix}.csv\",\n            mime=\"text/csv\",\n            key=f\"{key_prefix}_download\",\n        )\n\n    tables.aggrid_table(display_df, key_prefix=key_prefix)\n\n    if (df is None or df.empty) and empty_info:\n        st.info(empty_info)\n</code></pre>"}]}